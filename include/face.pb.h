// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: face.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_face_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_face_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_face_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_face_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_face_2eproto;
namespace face {
class Face;
struct FaceDefaultTypeInternal;
extern FaceDefaultTypeInternal _Face_default_instance_;
class FaceAttributes;
struct FaceAttributesDefaultTypeInternal;
extern FaceAttributesDefaultTypeInternal _FaceAttributes_default_instance_;
class FaceBox;
struct FaceBoxDefaultTypeInternal;
extern FaceBoxDefaultTypeInternal _FaceBox_default_instance_;
class FaceDetectionRequest;
struct FaceDetectionRequestDefaultTypeInternal;
extern FaceDetectionRequestDefaultTypeInternal _FaceDetectionRequest_default_instance_;
class FaceDetectionResponse;
struct FaceDetectionResponseDefaultTypeInternal;
extern FaceDetectionResponseDefaultTypeInternal _FaceDetectionResponse_default_instance_;
class FaceFeature;
struct FaceFeatureDefaultTypeInternal;
extern FaceFeatureDefaultTypeInternal _FaceFeature_default_instance_;
class FaceKeypoints106;
struct FaceKeypoints106DefaultTypeInternal;
extern FaceKeypoints106DefaultTypeInternal _FaceKeypoints106_default_instance_;
class FaceKeypoints5;
struct FaceKeypoints5DefaultTypeInternal;
extern FaceKeypoints5DefaultTypeInternal _FaceKeypoints5_default_instance_;
class FacePose;
struct FacePoseDefaultTypeInternal;
extern FacePoseDefaultTypeInternal _FacePose_default_instance_;
class FaceRecognitionRequest;
struct FaceRecognitionRequestDefaultTypeInternal;
extern FaceRecognitionRequestDefaultTypeInternal _FaceRecognitionRequest_default_instance_;
class FaceRecognitionResponse;
struct FaceRecognitionResponseDefaultTypeInternal;
extern FaceRecognitionResponseDefaultTypeInternal _FaceRecognitionResponse_default_instance_;
class FaceRecognitionResult;
struct FaceRecognitionResultDefaultTypeInternal;
extern FaceRecognitionResultDefaultTypeInternal _FaceRecognitionResult_default_instance_;
class FaceRecord;
struct FaceRecordDefaultTypeInternal;
extern FaceRecordDefaultTypeInternal _FaceRecord_default_instance_;
class Point2D;
struct Point2DDefaultTypeInternal;
extern Point2DDefaultTypeInternal _Point2D_default_instance_;
}  // namespace face
PROTOBUF_NAMESPACE_OPEN
template<> ::face::Face* Arena::CreateMaybeMessage<::face::Face>(Arena*);
template<> ::face::FaceAttributes* Arena::CreateMaybeMessage<::face::FaceAttributes>(Arena*);
template<> ::face::FaceBox* Arena::CreateMaybeMessage<::face::FaceBox>(Arena*);
template<> ::face::FaceDetectionRequest* Arena::CreateMaybeMessage<::face::FaceDetectionRequest>(Arena*);
template<> ::face::FaceDetectionResponse* Arena::CreateMaybeMessage<::face::FaceDetectionResponse>(Arena*);
template<> ::face::FaceFeature* Arena::CreateMaybeMessage<::face::FaceFeature>(Arena*);
template<> ::face::FaceKeypoints106* Arena::CreateMaybeMessage<::face::FaceKeypoints106>(Arena*);
template<> ::face::FaceKeypoints5* Arena::CreateMaybeMessage<::face::FaceKeypoints5>(Arena*);
template<> ::face::FacePose* Arena::CreateMaybeMessage<::face::FacePose>(Arena*);
template<> ::face::FaceRecognitionRequest* Arena::CreateMaybeMessage<::face::FaceRecognitionRequest>(Arena*);
template<> ::face::FaceRecognitionResponse* Arena::CreateMaybeMessage<::face::FaceRecognitionResponse>(Arena*);
template<> ::face::FaceRecognitionResult* Arena::CreateMaybeMessage<::face::FaceRecognitionResult>(Arena*);
template<> ::face::FaceRecord* Arena::CreateMaybeMessage<::face::FaceRecord>(Arena*);
template<> ::face::Point2D* Arena::CreateMaybeMessage<::face::Point2D>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace face {

enum FaceAttributes_Gender : int {
  FaceAttributes_Gender_UNKNOWN = 0,
  FaceAttributes_Gender_MALE = 1,
  FaceAttributes_Gender_FEMALE = 2,
  FaceAttributes_Gender_FaceAttributes_Gender_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FaceAttributes_Gender_FaceAttributes_Gender_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FaceAttributes_Gender_IsValid(int value);
constexpr FaceAttributes_Gender FaceAttributes_Gender_Gender_MIN = FaceAttributes_Gender_UNKNOWN;
constexpr FaceAttributes_Gender FaceAttributes_Gender_Gender_MAX = FaceAttributes_Gender_FEMALE;
constexpr int FaceAttributes_Gender_Gender_ARRAYSIZE = FaceAttributes_Gender_Gender_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FaceAttributes_Gender_descriptor();
template<typename T>
inline const std::string& FaceAttributes_Gender_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FaceAttributes_Gender>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FaceAttributes_Gender_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FaceAttributes_Gender_descriptor(), enum_t_value);
}
inline bool FaceAttributes_Gender_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FaceAttributes_Gender* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FaceAttributes_Gender>(
    FaceAttributes_Gender_descriptor(), name, value);
}
// ===================================================================

class FaceBox final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:face.FaceBox) */ {
 public:
  inline FaceBox() : FaceBox(nullptr) {}
  ~FaceBox() override;
  explicit PROTOBUF_CONSTEXPR FaceBox(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FaceBox(const FaceBox& from);
  FaceBox(FaceBox&& from) noexcept
    : FaceBox() {
    *this = ::std::move(from);
  }

  inline FaceBox& operator=(const FaceBox& from) {
    CopyFrom(from);
    return *this;
  }
  inline FaceBox& operator=(FaceBox&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FaceBox& default_instance() {
    return *internal_default_instance();
  }
  static inline const FaceBox* internal_default_instance() {
    return reinterpret_cast<const FaceBox*>(
               &_FaceBox_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FaceBox& a, FaceBox& b) {
    a.Swap(&b);
  }
  inline void Swap(FaceBox* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FaceBox* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FaceBox* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FaceBox>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FaceBox& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FaceBox& from) {
    FaceBox::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FaceBox* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "face.FaceBox";
  }
  protected:
  explicit FaceBox(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
    kScoreFieldNumber = 5,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float width = 3;
  void clear_width();
  float width() const;
  void set_width(float value);
  private:
  float _internal_width() const;
  void _internal_set_width(float value);
  public:

  // float height = 4;
  void clear_height();
  float height() const;
  void set_height(float value);
  private:
  float _internal_height() const;
  void _internal_set_height(float value);
  public:

  // float score = 5;
  void clear_score();
  float score() const;
  void set_score(float value);
  private:
  float _internal_score() const;
  void _internal_set_score(float value);
  public:

  // @@protoc_insertion_point(class_scope:face.FaceBox)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    float width_;
    float height_;
    float score_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_face_2eproto;
};
// -------------------------------------------------------------------

class Point2D final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:face.Point2D) */ {
 public:
  inline Point2D() : Point2D(nullptr) {}
  ~Point2D() override;
  explicit PROTOBUF_CONSTEXPR Point2D(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Point2D(const Point2D& from);
  Point2D(Point2D&& from) noexcept
    : Point2D() {
    *this = ::std::move(from);
  }

  inline Point2D& operator=(const Point2D& from) {
    CopyFrom(from);
    return *this;
  }
  inline Point2D& operator=(Point2D&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Point2D& default_instance() {
    return *internal_default_instance();
  }
  static inline const Point2D* internal_default_instance() {
    return reinterpret_cast<const Point2D*>(
               &_Point2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Point2D& a, Point2D& b) {
    a.Swap(&b);
  }
  inline void Swap(Point2D* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Point2D* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Point2D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Point2D>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Point2D& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Point2D& from) {
    Point2D::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point2D* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "face.Point2D";
  }
  protected:
  explicit Point2D(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:face.Point2D)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_face_2eproto;
};
// -------------------------------------------------------------------

class FaceKeypoints5 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:face.FaceKeypoints5) */ {
 public:
  inline FaceKeypoints5() : FaceKeypoints5(nullptr) {}
  ~FaceKeypoints5() override;
  explicit PROTOBUF_CONSTEXPR FaceKeypoints5(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FaceKeypoints5(const FaceKeypoints5& from);
  FaceKeypoints5(FaceKeypoints5&& from) noexcept
    : FaceKeypoints5() {
    *this = ::std::move(from);
  }

  inline FaceKeypoints5& operator=(const FaceKeypoints5& from) {
    CopyFrom(from);
    return *this;
  }
  inline FaceKeypoints5& operator=(FaceKeypoints5&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FaceKeypoints5& default_instance() {
    return *internal_default_instance();
  }
  static inline const FaceKeypoints5* internal_default_instance() {
    return reinterpret_cast<const FaceKeypoints5*>(
               &_FaceKeypoints5_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FaceKeypoints5& a, FaceKeypoints5& b) {
    a.Swap(&b);
  }
  inline void Swap(FaceKeypoints5* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FaceKeypoints5* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FaceKeypoints5* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FaceKeypoints5>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FaceKeypoints5& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FaceKeypoints5& from) {
    FaceKeypoints5::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FaceKeypoints5* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "face.FaceKeypoints5";
  }
  protected:
  explicit FaceKeypoints5(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeftEyeFieldNumber = 1,
    kRightEyeFieldNumber = 2,
    kNoseTipFieldNumber = 3,
    kMouthLeftFieldNumber = 4,
    kMouthRightFieldNumber = 5,
  };
  // .face.Point2D left_eye = 1;
  bool has_left_eye() const;
  private:
  bool _internal_has_left_eye() const;
  public:
  void clear_left_eye();
  const ::face::Point2D& left_eye() const;
  PROTOBUF_NODISCARD ::face::Point2D* release_left_eye();
  ::face::Point2D* mutable_left_eye();
  void set_allocated_left_eye(::face::Point2D* left_eye);
  private:
  const ::face::Point2D& _internal_left_eye() const;
  ::face::Point2D* _internal_mutable_left_eye();
  public:
  void unsafe_arena_set_allocated_left_eye(
      ::face::Point2D* left_eye);
  ::face::Point2D* unsafe_arena_release_left_eye();

  // .face.Point2D right_eye = 2;
  bool has_right_eye() const;
  private:
  bool _internal_has_right_eye() const;
  public:
  void clear_right_eye();
  const ::face::Point2D& right_eye() const;
  PROTOBUF_NODISCARD ::face::Point2D* release_right_eye();
  ::face::Point2D* mutable_right_eye();
  void set_allocated_right_eye(::face::Point2D* right_eye);
  private:
  const ::face::Point2D& _internal_right_eye() const;
  ::face::Point2D* _internal_mutable_right_eye();
  public:
  void unsafe_arena_set_allocated_right_eye(
      ::face::Point2D* right_eye);
  ::face::Point2D* unsafe_arena_release_right_eye();

  // .face.Point2D nose_tip = 3;
  bool has_nose_tip() const;
  private:
  bool _internal_has_nose_tip() const;
  public:
  void clear_nose_tip();
  const ::face::Point2D& nose_tip() const;
  PROTOBUF_NODISCARD ::face::Point2D* release_nose_tip();
  ::face::Point2D* mutable_nose_tip();
  void set_allocated_nose_tip(::face::Point2D* nose_tip);
  private:
  const ::face::Point2D& _internal_nose_tip() const;
  ::face::Point2D* _internal_mutable_nose_tip();
  public:
  void unsafe_arena_set_allocated_nose_tip(
      ::face::Point2D* nose_tip);
  ::face::Point2D* unsafe_arena_release_nose_tip();

  // .face.Point2D mouth_left = 4;
  bool has_mouth_left() const;
  private:
  bool _internal_has_mouth_left() const;
  public:
  void clear_mouth_left();
  const ::face::Point2D& mouth_left() const;
  PROTOBUF_NODISCARD ::face::Point2D* release_mouth_left();
  ::face::Point2D* mutable_mouth_left();
  void set_allocated_mouth_left(::face::Point2D* mouth_left);
  private:
  const ::face::Point2D& _internal_mouth_left() const;
  ::face::Point2D* _internal_mutable_mouth_left();
  public:
  void unsafe_arena_set_allocated_mouth_left(
      ::face::Point2D* mouth_left);
  ::face::Point2D* unsafe_arena_release_mouth_left();

  // .face.Point2D mouth_right = 5;
  bool has_mouth_right() const;
  private:
  bool _internal_has_mouth_right() const;
  public:
  void clear_mouth_right();
  const ::face::Point2D& mouth_right() const;
  PROTOBUF_NODISCARD ::face::Point2D* release_mouth_right();
  ::face::Point2D* mutable_mouth_right();
  void set_allocated_mouth_right(::face::Point2D* mouth_right);
  private:
  const ::face::Point2D& _internal_mouth_right() const;
  ::face::Point2D* _internal_mutable_mouth_right();
  public:
  void unsafe_arena_set_allocated_mouth_right(
      ::face::Point2D* mouth_right);
  ::face::Point2D* unsafe_arena_release_mouth_right();

  // @@protoc_insertion_point(class_scope:face.FaceKeypoints5)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::face::Point2D* left_eye_;
    ::face::Point2D* right_eye_;
    ::face::Point2D* nose_tip_;
    ::face::Point2D* mouth_left_;
    ::face::Point2D* mouth_right_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_face_2eproto;
};
// -------------------------------------------------------------------

class FaceKeypoints106 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:face.FaceKeypoints106) */ {
 public:
  inline FaceKeypoints106() : FaceKeypoints106(nullptr) {}
  ~FaceKeypoints106() override;
  explicit PROTOBUF_CONSTEXPR FaceKeypoints106(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FaceKeypoints106(const FaceKeypoints106& from);
  FaceKeypoints106(FaceKeypoints106&& from) noexcept
    : FaceKeypoints106() {
    *this = ::std::move(from);
  }

  inline FaceKeypoints106& operator=(const FaceKeypoints106& from) {
    CopyFrom(from);
    return *this;
  }
  inline FaceKeypoints106& operator=(FaceKeypoints106&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FaceKeypoints106& default_instance() {
    return *internal_default_instance();
  }
  static inline const FaceKeypoints106* internal_default_instance() {
    return reinterpret_cast<const FaceKeypoints106*>(
               &_FaceKeypoints106_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FaceKeypoints106& a, FaceKeypoints106& b) {
    a.Swap(&b);
  }
  inline void Swap(FaceKeypoints106* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FaceKeypoints106* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FaceKeypoints106* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FaceKeypoints106>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FaceKeypoints106& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FaceKeypoints106& from) {
    FaceKeypoints106::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FaceKeypoints106* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "face.FaceKeypoints106";
  }
  protected:
  explicit FaceKeypoints106(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 1,
  };
  // repeated .face.Point2D points = 1;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::face::Point2D* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::face::Point2D >*
      mutable_points();
  private:
  const ::face::Point2D& _internal_points(int index) const;
  ::face::Point2D* _internal_add_points();
  public:
  const ::face::Point2D& points(int index) const;
  ::face::Point2D* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::face::Point2D >&
      points() const;

  // @@protoc_insertion_point(class_scope:face.FaceKeypoints106)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::face::Point2D > points_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_face_2eproto;
};
// -------------------------------------------------------------------

class FacePose final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:face.FacePose) */ {
 public:
  inline FacePose() : FacePose(nullptr) {}
  ~FacePose() override;
  explicit PROTOBUF_CONSTEXPR FacePose(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FacePose(const FacePose& from);
  FacePose(FacePose&& from) noexcept
    : FacePose() {
    *this = ::std::move(from);
  }

  inline FacePose& operator=(const FacePose& from) {
    CopyFrom(from);
    return *this;
  }
  inline FacePose& operator=(FacePose&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FacePose& default_instance() {
    return *internal_default_instance();
  }
  static inline const FacePose* internal_default_instance() {
    return reinterpret_cast<const FacePose*>(
               &_FacePose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FacePose& a, FacePose& b) {
    a.Swap(&b);
  }
  inline void Swap(FacePose* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FacePose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FacePose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FacePose>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FacePose& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FacePose& from) {
    FacePose::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FacePose* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "face.FacePose";
  }
  protected:
  explicit FacePose(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPitchFieldNumber = 1,
    kYawFieldNumber = 2,
    kRollFieldNumber = 3,
  };
  // float pitch = 1;
  void clear_pitch();
  float pitch() const;
  void set_pitch(float value);
  private:
  float _internal_pitch() const;
  void _internal_set_pitch(float value);
  public:

  // float yaw = 2;
  void clear_yaw();
  float yaw() const;
  void set_yaw(float value);
  private:
  float _internal_yaw() const;
  void _internal_set_yaw(float value);
  public:

  // float roll = 3;
  void clear_roll();
  float roll() const;
  void set_roll(float value);
  private:
  float _internal_roll() const;
  void _internal_set_roll(float value);
  public:

  // @@protoc_insertion_point(class_scope:face.FacePose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float pitch_;
    float yaw_;
    float roll_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_face_2eproto;
};
// -------------------------------------------------------------------

class FaceAttributes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:face.FaceAttributes) */ {
 public:
  inline FaceAttributes() : FaceAttributes(nullptr) {}
  ~FaceAttributes() override;
  explicit PROTOBUF_CONSTEXPR FaceAttributes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FaceAttributes(const FaceAttributes& from);
  FaceAttributes(FaceAttributes&& from) noexcept
    : FaceAttributes() {
    *this = ::std::move(from);
  }

  inline FaceAttributes& operator=(const FaceAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  inline FaceAttributes& operator=(FaceAttributes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FaceAttributes& default_instance() {
    return *internal_default_instance();
  }
  static inline const FaceAttributes* internal_default_instance() {
    return reinterpret_cast<const FaceAttributes*>(
               &_FaceAttributes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(FaceAttributes& a, FaceAttributes& b) {
    a.Swap(&b);
  }
  inline void Swap(FaceAttributes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FaceAttributes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FaceAttributes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FaceAttributes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FaceAttributes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FaceAttributes& from) {
    FaceAttributes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FaceAttributes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "face.FaceAttributes";
  }
  protected:
  explicit FaceAttributes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FaceAttributes_Gender Gender;
  static constexpr Gender UNKNOWN =
    FaceAttributes_Gender_UNKNOWN;
  static constexpr Gender MALE =
    FaceAttributes_Gender_MALE;
  static constexpr Gender FEMALE =
    FaceAttributes_Gender_FEMALE;
  static inline bool Gender_IsValid(int value) {
    return FaceAttributes_Gender_IsValid(value);
  }
  static constexpr Gender Gender_MIN =
    FaceAttributes_Gender_Gender_MIN;
  static constexpr Gender Gender_MAX =
    FaceAttributes_Gender_Gender_MAX;
  static constexpr int Gender_ARRAYSIZE =
    FaceAttributes_Gender_Gender_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Gender_descriptor() {
    return FaceAttributes_Gender_descriptor();
  }
  template<typename T>
  static inline const std::string& Gender_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Gender>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Gender_Name.");
    return FaceAttributes_Gender_Name(enum_t_value);
  }
  static inline bool Gender_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Gender* value) {
    return FaceAttributes_Gender_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAgeFieldNumber = 1,
    kGenderFieldNumber = 2,
  };
  // float age = 1;
  void clear_age();
  float age() const;
  void set_age(float value);
  private:
  float _internal_age() const;
  void _internal_set_age(float value);
  public:

  // .face.FaceAttributes.Gender gender = 2;
  void clear_gender();
  ::face::FaceAttributes_Gender gender() const;
  void set_gender(::face::FaceAttributes_Gender value);
  private:
  ::face::FaceAttributes_Gender _internal_gender() const;
  void _internal_set_gender(::face::FaceAttributes_Gender value);
  public:

  // @@protoc_insertion_point(class_scope:face.FaceAttributes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float age_;
    int gender_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_face_2eproto;
};
// -------------------------------------------------------------------

class FaceFeature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:face.FaceFeature) */ {
 public:
  inline FaceFeature() : FaceFeature(nullptr) {}
  ~FaceFeature() override;
  explicit PROTOBUF_CONSTEXPR FaceFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FaceFeature(const FaceFeature& from);
  FaceFeature(FaceFeature&& from) noexcept
    : FaceFeature() {
    *this = ::std::move(from);
  }

  inline FaceFeature& operator=(const FaceFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline FaceFeature& operator=(FaceFeature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FaceFeature& default_instance() {
    return *internal_default_instance();
  }
  static inline const FaceFeature* internal_default_instance() {
    return reinterpret_cast<const FaceFeature*>(
               &_FaceFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(FaceFeature& a, FaceFeature& b) {
    a.Swap(&b);
  }
  inline void Swap(FaceFeature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FaceFeature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FaceFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FaceFeature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FaceFeature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FaceFeature& from) {
    FaceFeature::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FaceFeature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "face.FaceFeature";
  }
  protected:
  explicit FaceFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVectorFieldNumber = 1,
    kModelVersionFieldNumber = 2,
  };
  // repeated float vector = 1;
  int vector_size() const;
  private:
  int _internal_vector_size() const;
  public:
  void clear_vector();
  private:
  float _internal_vector(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_vector() const;
  void _internal_add_vector(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_vector();
  public:
  float vector(int index) const;
  void set_vector(int index, float value);
  void add_vector(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      vector() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_vector();

  // string model_version = 2;
  void clear_model_version();
  const std::string& model_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_version();
  PROTOBUF_NODISCARD std::string* release_model_version();
  void set_allocated_model_version(std::string* model_version);
  private:
  const std::string& _internal_model_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_version(const std::string& value);
  std::string* _internal_mutable_model_version();
  public:

  // @@protoc_insertion_point(class_scope:face.FaceFeature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > vector_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_face_2eproto;
};
// -------------------------------------------------------------------

class FaceRecognitionResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:face.FaceRecognitionResult) */ {
 public:
  inline FaceRecognitionResult() : FaceRecognitionResult(nullptr) {}
  ~FaceRecognitionResult() override;
  explicit PROTOBUF_CONSTEXPR FaceRecognitionResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FaceRecognitionResult(const FaceRecognitionResult& from);
  FaceRecognitionResult(FaceRecognitionResult&& from) noexcept
    : FaceRecognitionResult() {
    *this = ::std::move(from);
  }

  inline FaceRecognitionResult& operator=(const FaceRecognitionResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline FaceRecognitionResult& operator=(FaceRecognitionResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FaceRecognitionResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const FaceRecognitionResult* internal_default_instance() {
    return reinterpret_cast<const FaceRecognitionResult*>(
               &_FaceRecognitionResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(FaceRecognitionResult& a, FaceRecognitionResult& b) {
    a.Swap(&b);
  }
  inline void Swap(FaceRecognitionResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FaceRecognitionResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FaceRecognitionResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FaceRecognitionResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FaceRecognitionResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FaceRecognitionResult& from) {
    FaceRecognitionResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FaceRecognitionResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "face.FaceRecognitionResult";
  }
  protected:
  explicit FaceRecognitionResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFaceIdFieldNumber = 1,
    kSimilarityFieldNumber = 3,
  };
  // string face_id = 1;
  void clear_face_id();
  const std::string& face_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_face_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_face_id();
  PROTOBUF_NODISCARD std::string* release_face_id();
  void set_allocated_face_id(std::string* face_id);
  private:
  const std::string& _internal_face_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_face_id(const std::string& value);
  std::string* _internal_mutable_face_id();
  public:

  // float similarity = 3;
  void clear_similarity();
  float similarity() const;
  void set_similarity(float value);
  private:
  float _internal_similarity() const;
  void _internal_set_similarity(float value);
  public:

  // @@protoc_insertion_point(class_scope:face.FaceRecognitionResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr face_id_;
    float similarity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_face_2eproto;
};
// -------------------------------------------------------------------

class Face final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:face.Face) */ {
 public:
  inline Face() : Face(nullptr) {}
  ~Face() override;
  explicit PROTOBUF_CONSTEXPR Face(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Face(const Face& from);
  Face(Face&& from) noexcept
    : Face() {
    *this = ::std::move(from);
  }

  inline Face& operator=(const Face& from) {
    CopyFrom(from);
    return *this;
  }
  inline Face& operator=(Face&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Face& default_instance() {
    return *internal_default_instance();
  }
  static inline const Face* internal_default_instance() {
    return reinterpret_cast<const Face*>(
               &_Face_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Face& a, Face& b) {
    a.Swap(&b);
  }
  inline void Swap(Face* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Face* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Face* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Face>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Face& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Face& from) {
    Face::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Face* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "face.Face";
  }
  protected:
  explicit Face(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageIdFieldNumber = 1,
    kBoxFieldNumber = 3,
    kKeypoints5FieldNumber = 4,
    kKeypoints106FieldNumber = 5,
    kPoseFieldNumber = 6,
    kAttributesFieldNumber = 7,
    kFeatureFieldNumber = 8,
    kRecognitionFieldNumber = 9,
    kTimestampFieldNumber = 10,
    kFaceIndexFieldNumber = 2,
  };
  // string image_id = 1;
  void clear_image_id();
  const std::string& image_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image_id();
  PROTOBUF_NODISCARD std::string* release_image_id();
  void set_allocated_image_id(std::string* image_id);
  private:
  const std::string& _internal_image_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image_id(const std::string& value);
  std::string* _internal_mutable_image_id();
  public:

  // .face.FaceBox box = 3;
  bool has_box() const;
  private:
  bool _internal_has_box() const;
  public:
  void clear_box();
  const ::face::FaceBox& box() const;
  PROTOBUF_NODISCARD ::face::FaceBox* release_box();
  ::face::FaceBox* mutable_box();
  void set_allocated_box(::face::FaceBox* box);
  private:
  const ::face::FaceBox& _internal_box() const;
  ::face::FaceBox* _internal_mutable_box();
  public:
  void unsafe_arena_set_allocated_box(
      ::face::FaceBox* box);
  ::face::FaceBox* unsafe_arena_release_box();

  // .face.FaceKeypoints5 keypoints5 = 4;
  bool has_keypoints5() const;
  private:
  bool _internal_has_keypoints5() const;
  public:
  void clear_keypoints5();
  const ::face::FaceKeypoints5& keypoints5() const;
  PROTOBUF_NODISCARD ::face::FaceKeypoints5* release_keypoints5();
  ::face::FaceKeypoints5* mutable_keypoints5();
  void set_allocated_keypoints5(::face::FaceKeypoints5* keypoints5);
  private:
  const ::face::FaceKeypoints5& _internal_keypoints5() const;
  ::face::FaceKeypoints5* _internal_mutable_keypoints5();
  public:
  void unsafe_arena_set_allocated_keypoints5(
      ::face::FaceKeypoints5* keypoints5);
  ::face::FaceKeypoints5* unsafe_arena_release_keypoints5();

  // .face.FaceKeypoints106 keypoints106 = 5;
  bool has_keypoints106() const;
  private:
  bool _internal_has_keypoints106() const;
  public:
  void clear_keypoints106();
  const ::face::FaceKeypoints106& keypoints106() const;
  PROTOBUF_NODISCARD ::face::FaceKeypoints106* release_keypoints106();
  ::face::FaceKeypoints106* mutable_keypoints106();
  void set_allocated_keypoints106(::face::FaceKeypoints106* keypoints106);
  private:
  const ::face::FaceKeypoints106& _internal_keypoints106() const;
  ::face::FaceKeypoints106* _internal_mutable_keypoints106();
  public:
  void unsafe_arena_set_allocated_keypoints106(
      ::face::FaceKeypoints106* keypoints106);
  ::face::FaceKeypoints106* unsafe_arena_release_keypoints106();

  // .face.FacePose pose = 6;
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::face::FacePose& pose() const;
  PROTOBUF_NODISCARD ::face::FacePose* release_pose();
  ::face::FacePose* mutable_pose();
  void set_allocated_pose(::face::FacePose* pose);
  private:
  const ::face::FacePose& _internal_pose() const;
  ::face::FacePose* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::face::FacePose* pose);
  ::face::FacePose* unsafe_arena_release_pose();

  // .face.FaceAttributes attributes = 7;
  bool has_attributes() const;
  private:
  bool _internal_has_attributes() const;
  public:
  void clear_attributes();
  const ::face::FaceAttributes& attributes() const;
  PROTOBUF_NODISCARD ::face::FaceAttributes* release_attributes();
  ::face::FaceAttributes* mutable_attributes();
  void set_allocated_attributes(::face::FaceAttributes* attributes);
  private:
  const ::face::FaceAttributes& _internal_attributes() const;
  ::face::FaceAttributes* _internal_mutable_attributes();
  public:
  void unsafe_arena_set_allocated_attributes(
      ::face::FaceAttributes* attributes);
  ::face::FaceAttributes* unsafe_arena_release_attributes();

  // .face.FaceFeature feature = 8;
  bool has_feature() const;
  private:
  bool _internal_has_feature() const;
  public:
  void clear_feature();
  const ::face::FaceFeature& feature() const;
  PROTOBUF_NODISCARD ::face::FaceFeature* release_feature();
  ::face::FaceFeature* mutable_feature();
  void set_allocated_feature(::face::FaceFeature* feature);
  private:
  const ::face::FaceFeature& _internal_feature() const;
  ::face::FaceFeature* _internal_mutable_feature();
  public:
  void unsafe_arena_set_allocated_feature(
      ::face::FaceFeature* feature);
  ::face::FaceFeature* unsafe_arena_release_feature();

  // .face.FaceRecognitionResult recognition = 9;
  bool has_recognition() const;
  private:
  bool _internal_has_recognition() const;
  public:
  void clear_recognition();
  const ::face::FaceRecognitionResult& recognition() const;
  PROTOBUF_NODISCARD ::face::FaceRecognitionResult* release_recognition();
  ::face::FaceRecognitionResult* mutable_recognition();
  void set_allocated_recognition(::face::FaceRecognitionResult* recognition);
  private:
  const ::face::FaceRecognitionResult& _internal_recognition() const;
  ::face::FaceRecognitionResult* _internal_mutable_recognition();
  public:
  void unsafe_arena_set_allocated_recognition(
      ::face::FaceRecognitionResult* recognition);
  ::face::FaceRecognitionResult* unsafe_arena_release_recognition();

  // int64 timestamp = 10;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // int32 face_index = 2;
  void clear_face_index();
  int32_t face_index() const;
  void set_face_index(int32_t value);
  private:
  int32_t _internal_face_index() const;
  void _internal_set_face_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:face.Face)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_id_;
    ::face::FaceBox* box_;
    ::face::FaceKeypoints5* keypoints5_;
    ::face::FaceKeypoints106* keypoints106_;
    ::face::FacePose* pose_;
    ::face::FaceAttributes* attributes_;
    ::face::FaceFeature* feature_;
    ::face::FaceRecognitionResult* recognition_;
    int64_t timestamp_;
    int32_t face_index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_face_2eproto;
};
// -------------------------------------------------------------------

class FaceRecord final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:face.FaceRecord) */ {
 public:
  inline FaceRecord() : FaceRecord(nullptr) {}
  ~FaceRecord() override;
  explicit PROTOBUF_CONSTEXPR FaceRecord(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FaceRecord(const FaceRecord& from);
  FaceRecord(FaceRecord&& from) noexcept
    : FaceRecord() {
    *this = ::std::move(from);
  }

  inline FaceRecord& operator=(const FaceRecord& from) {
    CopyFrom(from);
    return *this;
  }
  inline FaceRecord& operator=(FaceRecord&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FaceRecord& default_instance() {
    return *internal_default_instance();
  }
  static inline const FaceRecord* internal_default_instance() {
    return reinterpret_cast<const FaceRecord*>(
               &_FaceRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(FaceRecord& a, FaceRecord& b) {
    a.Swap(&b);
  }
  inline void Swap(FaceRecord* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FaceRecord* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FaceRecord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FaceRecord>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FaceRecord& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FaceRecord& from) {
    FaceRecord::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FaceRecord* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "face.FaceRecord";
  }
  protected:
  explicit FaceRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFaceIdFieldNumber = 1,
    kPersonIdFieldNumber = 2,
    kNameFieldNumber = 3,
    kFaceImageFieldNumber = 5,
    kFeatureFieldNumber = 4,
    kCreateTimeFieldNumber = 6,
    kUpdateTimeFieldNumber = 7,
  };
  // string face_id = 1;
  void clear_face_id();
  const std::string& face_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_face_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_face_id();
  PROTOBUF_NODISCARD std::string* release_face_id();
  void set_allocated_face_id(std::string* face_id);
  private:
  const std::string& _internal_face_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_face_id(const std::string& value);
  std::string* _internal_mutable_face_id();
  public:

  // string person_id = 2;
  void clear_person_id();
  const std::string& person_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_person_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_person_id();
  PROTOBUF_NODISCARD std::string* release_person_id();
  void set_allocated_person_id(std::string* person_id);
  private:
  const std::string& _internal_person_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_person_id(const std::string& value);
  std::string* _internal_mutable_person_id();
  public:

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes face_image = 5;
  void clear_face_image();
  const std::string& face_image() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_face_image(ArgT0&& arg0, ArgT... args);
  std::string* mutable_face_image();
  PROTOBUF_NODISCARD std::string* release_face_image();
  void set_allocated_face_image(std::string* face_image);
  private:
  const std::string& _internal_face_image() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_face_image(const std::string& value);
  std::string* _internal_mutable_face_image();
  public:

  // .face.FaceFeature feature = 4;
  bool has_feature() const;
  private:
  bool _internal_has_feature() const;
  public:
  void clear_feature();
  const ::face::FaceFeature& feature() const;
  PROTOBUF_NODISCARD ::face::FaceFeature* release_feature();
  ::face::FaceFeature* mutable_feature();
  void set_allocated_feature(::face::FaceFeature* feature);
  private:
  const ::face::FaceFeature& _internal_feature() const;
  ::face::FaceFeature* _internal_mutable_feature();
  public:
  void unsafe_arena_set_allocated_feature(
      ::face::FaceFeature* feature);
  ::face::FaceFeature* unsafe_arena_release_feature();

  // int64 create_time = 6;
  void clear_create_time();
  int64_t create_time() const;
  void set_create_time(int64_t value);
  private:
  int64_t _internal_create_time() const;
  void _internal_set_create_time(int64_t value);
  public:

  // int64 update_time = 7;
  void clear_update_time();
  int64_t update_time() const;
  void set_update_time(int64_t value);
  private:
  int64_t _internal_update_time() const;
  void _internal_set_update_time(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:face.FaceRecord)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr face_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr person_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr face_image_;
    ::face::FaceFeature* feature_;
    int64_t create_time_;
    int64_t update_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_face_2eproto;
};
// -------------------------------------------------------------------

class FaceDetectionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:face.FaceDetectionRequest) */ {
 public:
  inline FaceDetectionRequest() : FaceDetectionRequest(nullptr) {}
  ~FaceDetectionRequest() override;
  explicit PROTOBUF_CONSTEXPR FaceDetectionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FaceDetectionRequest(const FaceDetectionRequest& from);
  FaceDetectionRequest(FaceDetectionRequest&& from) noexcept
    : FaceDetectionRequest() {
    *this = ::std::move(from);
  }

  inline FaceDetectionRequest& operator=(const FaceDetectionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FaceDetectionRequest& operator=(FaceDetectionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FaceDetectionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FaceDetectionRequest* internal_default_instance() {
    return reinterpret_cast<const FaceDetectionRequest*>(
               &_FaceDetectionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(FaceDetectionRequest& a, FaceDetectionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FaceDetectionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FaceDetectionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FaceDetectionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FaceDetectionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FaceDetectionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FaceDetectionRequest& from) {
    FaceDetectionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FaceDetectionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "face.FaceDetectionRequest";
  }
  protected:
  explicit FaceDetectionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageFieldNumber = 1,
    kExtractKeypoints5FieldNumber = 2,
    kExtractKeypoints106FieldNumber = 3,
    kExtractAttributesFieldNumber = 4,
    kExtractFeatureFieldNumber = 5,
  };
  // bytes image = 1;
  void clear_image();
  const std::string& image() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image();
  PROTOBUF_NODISCARD std::string* release_image();
  void set_allocated_image(std::string* image);
  private:
  const std::string& _internal_image() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image(const std::string& value);
  std::string* _internal_mutable_image();
  public:

  // bool extract_keypoints5 = 2;
  void clear_extract_keypoints5();
  bool extract_keypoints5() const;
  void set_extract_keypoints5(bool value);
  private:
  bool _internal_extract_keypoints5() const;
  void _internal_set_extract_keypoints5(bool value);
  public:

  // bool extract_keypoints106 = 3;
  void clear_extract_keypoints106();
  bool extract_keypoints106() const;
  void set_extract_keypoints106(bool value);
  private:
  bool _internal_extract_keypoints106() const;
  void _internal_set_extract_keypoints106(bool value);
  public:

  // bool extract_attributes = 4;
  void clear_extract_attributes();
  bool extract_attributes() const;
  void set_extract_attributes(bool value);
  private:
  bool _internal_extract_attributes() const;
  void _internal_set_extract_attributes(bool value);
  public:

  // bool extract_feature = 5;
  void clear_extract_feature();
  bool extract_feature() const;
  void set_extract_feature(bool value);
  private:
  bool _internal_extract_feature() const;
  void _internal_set_extract_feature(bool value);
  public:

  // @@protoc_insertion_point(class_scope:face.FaceDetectionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_;
    bool extract_keypoints5_;
    bool extract_keypoints106_;
    bool extract_attributes_;
    bool extract_feature_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_face_2eproto;
};
// -------------------------------------------------------------------

class FaceDetectionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:face.FaceDetectionResponse) */ {
 public:
  inline FaceDetectionResponse() : FaceDetectionResponse(nullptr) {}
  ~FaceDetectionResponse() override;
  explicit PROTOBUF_CONSTEXPR FaceDetectionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FaceDetectionResponse(const FaceDetectionResponse& from);
  FaceDetectionResponse(FaceDetectionResponse&& from) noexcept
    : FaceDetectionResponse() {
    *this = ::std::move(from);
  }

  inline FaceDetectionResponse& operator=(const FaceDetectionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FaceDetectionResponse& operator=(FaceDetectionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FaceDetectionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FaceDetectionResponse* internal_default_instance() {
    return reinterpret_cast<const FaceDetectionResponse*>(
               &_FaceDetectionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(FaceDetectionResponse& a, FaceDetectionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FaceDetectionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FaceDetectionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FaceDetectionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FaceDetectionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FaceDetectionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FaceDetectionResponse& from) {
    FaceDetectionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FaceDetectionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "face.FaceDetectionResponse";
  }
  protected:
  explicit FaceDetectionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFacesFieldNumber = 1,
    kErrorMsgFieldNumber = 3,
    kErrorCodeFieldNumber = 2,
  };
  // repeated .face.Face faces = 1;
  int faces_size() const;
  private:
  int _internal_faces_size() const;
  public:
  void clear_faces();
  ::face::Face* mutable_faces(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::face::Face >*
      mutable_faces();
  private:
  const ::face::Face& _internal_faces(int index) const;
  ::face::Face* _internal_add_faces();
  public:
  const ::face::Face& faces(int index) const;
  ::face::Face* add_faces();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::face::Face >&
      faces() const;

  // string error_msg = 3;
  void clear_error_msg();
  const std::string& error_msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_msg();
  PROTOBUF_NODISCARD std::string* release_error_msg();
  void set_allocated_error_msg(std::string* error_msg);
  private:
  const std::string& _internal_error_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_msg(const std::string& value);
  std::string* _internal_mutable_error_msg();
  public:

  // int32 error_code = 2;
  void clear_error_code();
  int32_t error_code() const;
  void set_error_code(int32_t value);
  private:
  int32_t _internal_error_code() const;
  void _internal_set_error_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:face.FaceDetectionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::face::Face > faces_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_msg_;
    int32_t error_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_face_2eproto;
};
// -------------------------------------------------------------------

class FaceRecognitionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:face.FaceRecognitionRequest) */ {
 public:
  inline FaceRecognitionRequest() : FaceRecognitionRequest(nullptr) {}
  ~FaceRecognitionRequest() override;
  explicit PROTOBUF_CONSTEXPR FaceRecognitionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FaceRecognitionRequest(const FaceRecognitionRequest& from);
  FaceRecognitionRequest(FaceRecognitionRequest&& from) noexcept
    : FaceRecognitionRequest() {
    *this = ::std::move(from);
  }

  inline FaceRecognitionRequest& operator=(const FaceRecognitionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FaceRecognitionRequest& operator=(FaceRecognitionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FaceRecognitionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FaceRecognitionRequest* internal_default_instance() {
    return reinterpret_cast<const FaceRecognitionRequest*>(
               &_FaceRecognitionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(FaceRecognitionRequest& a, FaceRecognitionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FaceRecognitionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FaceRecognitionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FaceRecognitionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FaceRecognitionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FaceRecognitionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FaceRecognitionRequest& from) {
    FaceRecognitionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FaceRecognitionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "face.FaceRecognitionRequest";
  }
  protected:
  explicit FaceRecognitionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeatureFieldNumber = 1,
    kTopNFieldNumber = 2,
    kThresholdFieldNumber = 3,
  };
  // .face.FaceFeature feature = 1;
  bool has_feature() const;
  private:
  bool _internal_has_feature() const;
  public:
  void clear_feature();
  const ::face::FaceFeature& feature() const;
  PROTOBUF_NODISCARD ::face::FaceFeature* release_feature();
  ::face::FaceFeature* mutable_feature();
  void set_allocated_feature(::face::FaceFeature* feature);
  private:
  const ::face::FaceFeature& _internal_feature() const;
  ::face::FaceFeature* _internal_mutable_feature();
  public:
  void unsafe_arena_set_allocated_feature(
      ::face::FaceFeature* feature);
  ::face::FaceFeature* unsafe_arena_release_feature();

  // int32 top_n = 2;
  void clear_top_n();
  int32_t top_n() const;
  void set_top_n(int32_t value);
  private:
  int32_t _internal_top_n() const;
  void _internal_set_top_n(int32_t value);
  public:

  // float threshold = 3;
  void clear_threshold();
  float threshold() const;
  void set_threshold(float value);
  private:
  float _internal_threshold() const;
  void _internal_set_threshold(float value);
  public:

  // @@protoc_insertion_point(class_scope:face.FaceRecognitionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::face::FaceFeature* feature_;
    int32_t top_n_;
    float threshold_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_face_2eproto;
};
// -------------------------------------------------------------------

class FaceRecognitionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:face.FaceRecognitionResponse) */ {
 public:
  inline FaceRecognitionResponse() : FaceRecognitionResponse(nullptr) {}
  ~FaceRecognitionResponse() override;
  explicit PROTOBUF_CONSTEXPR FaceRecognitionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FaceRecognitionResponse(const FaceRecognitionResponse& from);
  FaceRecognitionResponse(FaceRecognitionResponse&& from) noexcept
    : FaceRecognitionResponse() {
    *this = ::std::move(from);
  }

  inline FaceRecognitionResponse& operator=(const FaceRecognitionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FaceRecognitionResponse& operator=(FaceRecognitionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FaceRecognitionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FaceRecognitionResponse* internal_default_instance() {
    return reinterpret_cast<const FaceRecognitionResponse*>(
               &_FaceRecognitionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(FaceRecognitionResponse& a, FaceRecognitionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FaceRecognitionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FaceRecognitionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FaceRecognitionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FaceRecognitionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FaceRecognitionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FaceRecognitionResponse& from) {
    FaceRecognitionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FaceRecognitionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "face.FaceRecognitionResponse";
  }
  protected:
  explicit FaceRecognitionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 1,
    kErrorMsgFieldNumber = 3,
    kErrorCodeFieldNumber = 2,
  };
  // repeated .face.FaceRecognitionResult results = 1;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::face::FaceRecognitionResult* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::face::FaceRecognitionResult >*
      mutable_results();
  private:
  const ::face::FaceRecognitionResult& _internal_results(int index) const;
  ::face::FaceRecognitionResult* _internal_add_results();
  public:
  const ::face::FaceRecognitionResult& results(int index) const;
  ::face::FaceRecognitionResult* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::face::FaceRecognitionResult >&
      results() const;

  // string error_msg = 3;
  void clear_error_msg();
  const std::string& error_msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_msg();
  PROTOBUF_NODISCARD std::string* release_error_msg();
  void set_allocated_error_msg(std::string* error_msg);
  private:
  const std::string& _internal_error_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_msg(const std::string& value);
  std::string* _internal_mutable_error_msg();
  public:

  // int32 error_code = 2;
  void clear_error_code();
  int32_t error_code() const;
  void set_error_code(int32_t value);
  private:
  int32_t _internal_error_code() const;
  void _internal_set_error_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:face.FaceRecognitionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::face::FaceRecognitionResult > results_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_msg_;
    int32_t error_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_face_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FaceBox

// float x = 1;
inline void FaceBox::clear_x() {
  _impl_.x_ = 0;
}
inline float FaceBox::_internal_x() const {
  return _impl_.x_;
}
inline float FaceBox::x() const {
  // @@protoc_insertion_point(field_get:face.FaceBox.x)
  return _internal_x();
}
inline void FaceBox::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void FaceBox::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:face.FaceBox.x)
}

// float y = 2;
inline void FaceBox::clear_y() {
  _impl_.y_ = 0;
}
inline float FaceBox::_internal_y() const {
  return _impl_.y_;
}
inline float FaceBox::y() const {
  // @@protoc_insertion_point(field_get:face.FaceBox.y)
  return _internal_y();
}
inline void FaceBox::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void FaceBox::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:face.FaceBox.y)
}

// float width = 3;
inline void FaceBox::clear_width() {
  _impl_.width_ = 0;
}
inline float FaceBox::_internal_width() const {
  return _impl_.width_;
}
inline float FaceBox::width() const {
  // @@protoc_insertion_point(field_get:face.FaceBox.width)
  return _internal_width();
}
inline void FaceBox::_internal_set_width(float value) {
  
  _impl_.width_ = value;
}
inline void FaceBox::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:face.FaceBox.width)
}

// float height = 4;
inline void FaceBox::clear_height() {
  _impl_.height_ = 0;
}
inline float FaceBox::_internal_height() const {
  return _impl_.height_;
}
inline float FaceBox::height() const {
  // @@protoc_insertion_point(field_get:face.FaceBox.height)
  return _internal_height();
}
inline void FaceBox::_internal_set_height(float value) {
  
  _impl_.height_ = value;
}
inline void FaceBox::set_height(float value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:face.FaceBox.height)
}

// float score = 5;
inline void FaceBox::clear_score() {
  _impl_.score_ = 0;
}
inline float FaceBox::_internal_score() const {
  return _impl_.score_;
}
inline float FaceBox::score() const {
  // @@protoc_insertion_point(field_get:face.FaceBox.score)
  return _internal_score();
}
inline void FaceBox::_internal_set_score(float value) {
  
  _impl_.score_ = value;
}
inline void FaceBox::set_score(float value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:face.FaceBox.score)
}

// -------------------------------------------------------------------

// Point2D

// float x = 1;
inline void Point2D::clear_x() {
  _impl_.x_ = 0;
}
inline float Point2D::_internal_x() const {
  return _impl_.x_;
}
inline float Point2D::x() const {
  // @@protoc_insertion_point(field_get:face.Point2D.x)
  return _internal_x();
}
inline void Point2D::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void Point2D::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:face.Point2D.x)
}

// float y = 2;
inline void Point2D::clear_y() {
  _impl_.y_ = 0;
}
inline float Point2D::_internal_y() const {
  return _impl_.y_;
}
inline float Point2D::y() const {
  // @@protoc_insertion_point(field_get:face.Point2D.y)
  return _internal_y();
}
inline void Point2D::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void Point2D::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:face.Point2D.y)
}

// -------------------------------------------------------------------

// FaceKeypoints5

// .face.Point2D left_eye = 1;
inline bool FaceKeypoints5::_internal_has_left_eye() const {
  return this != internal_default_instance() && _impl_.left_eye_ != nullptr;
}
inline bool FaceKeypoints5::has_left_eye() const {
  return _internal_has_left_eye();
}
inline void FaceKeypoints5::clear_left_eye() {
  if (GetArenaForAllocation() == nullptr && _impl_.left_eye_ != nullptr) {
    delete _impl_.left_eye_;
  }
  _impl_.left_eye_ = nullptr;
}
inline const ::face::Point2D& FaceKeypoints5::_internal_left_eye() const {
  const ::face::Point2D* p = _impl_.left_eye_;
  return p != nullptr ? *p : reinterpret_cast<const ::face::Point2D&>(
      ::face::_Point2D_default_instance_);
}
inline const ::face::Point2D& FaceKeypoints5::left_eye() const {
  // @@protoc_insertion_point(field_get:face.FaceKeypoints5.left_eye)
  return _internal_left_eye();
}
inline void FaceKeypoints5::unsafe_arena_set_allocated_left_eye(
    ::face::Point2D* left_eye) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.left_eye_);
  }
  _impl_.left_eye_ = left_eye;
  if (left_eye) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:face.FaceKeypoints5.left_eye)
}
inline ::face::Point2D* FaceKeypoints5::release_left_eye() {
  
  ::face::Point2D* temp = _impl_.left_eye_;
  _impl_.left_eye_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::face::Point2D* FaceKeypoints5::unsafe_arena_release_left_eye() {
  // @@protoc_insertion_point(field_release:face.FaceKeypoints5.left_eye)
  
  ::face::Point2D* temp = _impl_.left_eye_;
  _impl_.left_eye_ = nullptr;
  return temp;
}
inline ::face::Point2D* FaceKeypoints5::_internal_mutable_left_eye() {
  
  if (_impl_.left_eye_ == nullptr) {
    auto* p = CreateMaybeMessage<::face::Point2D>(GetArenaForAllocation());
    _impl_.left_eye_ = p;
  }
  return _impl_.left_eye_;
}
inline ::face::Point2D* FaceKeypoints5::mutable_left_eye() {
  ::face::Point2D* _msg = _internal_mutable_left_eye();
  // @@protoc_insertion_point(field_mutable:face.FaceKeypoints5.left_eye)
  return _msg;
}
inline void FaceKeypoints5::set_allocated_left_eye(::face::Point2D* left_eye) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.left_eye_;
  }
  if (left_eye) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(left_eye);
    if (message_arena != submessage_arena) {
      left_eye = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left_eye, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.left_eye_ = left_eye;
  // @@protoc_insertion_point(field_set_allocated:face.FaceKeypoints5.left_eye)
}

// .face.Point2D right_eye = 2;
inline bool FaceKeypoints5::_internal_has_right_eye() const {
  return this != internal_default_instance() && _impl_.right_eye_ != nullptr;
}
inline bool FaceKeypoints5::has_right_eye() const {
  return _internal_has_right_eye();
}
inline void FaceKeypoints5::clear_right_eye() {
  if (GetArenaForAllocation() == nullptr && _impl_.right_eye_ != nullptr) {
    delete _impl_.right_eye_;
  }
  _impl_.right_eye_ = nullptr;
}
inline const ::face::Point2D& FaceKeypoints5::_internal_right_eye() const {
  const ::face::Point2D* p = _impl_.right_eye_;
  return p != nullptr ? *p : reinterpret_cast<const ::face::Point2D&>(
      ::face::_Point2D_default_instance_);
}
inline const ::face::Point2D& FaceKeypoints5::right_eye() const {
  // @@protoc_insertion_point(field_get:face.FaceKeypoints5.right_eye)
  return _internal_right_eye();
}
inline void FaceKeypoints5::unsafe_arena_set_allocated_right_eye(
    ::face::Point2D* right_eye) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.right_eye_);
  }
  _impl_.right_eye_ = right_eye;
  if (right_eye) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:face.FaceKeypoints5.right_eye)
}
inline ::face::Point2D* FaceKeypoints5::release_right_eye() {
  
  ::face::Point2D* temp = _impl_.right_eye_;
  _impl_.right_eye_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::face::Point2D* FaceKeypoints5::unsafe_arena_release_right_eye() {
  // @@protoc_insertion_point(field_release:face.FaceKeypoints5.right_eye)
  
  ::face::Point2D* temp = _impl_.right_eye_;
  _impl_.right_eye_ = nullptr;
  return temp;
}
inline ::face::Point2D* FaceKeypoints5::_internal_mutable_right_eye() {
  
  if (_impl_.right_eye_ == nullptr) {
    auto* p = CreateMaybeMessage<::face::Point2D>(GetArenaForAllocation());
    _impl_.right_eye_ = p;
  }
  return _impl_.right_eye_;
}
inline ::face::Point2D* FaceKeypoints5::mutable_right_eye() {
  ::face::Point2D* _msg = _internal_mutable_right_eye();
  // @@protoc_insertion_point(field_mutable:face.FaceKeypoints5.right_eye)
  return _msg;
}
inline void FaceKeypoints5::set_allocated_right_eye(::face::Point2D* right_eye) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.right_eye_;
  }
  if (right_eye) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(right_eye);
    if (message_arena != submessage_arena) {
      right_eye = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right_eye, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.right_eye_ = right_eye;
  // @@protoc_insertion_point(field_set_allocated:face.FaceKeypoints5.right_eye)
}

// .face.Point2D nose_tip = 3;
inline bool FaceKeypoints5::_internal_has_nose_tip() const {
  return this != internal_default_instance() && _impl_.nose_tip_ != nullptr;
}
inline bool FaceKeypoints5::has_nose_tip() const {
  return _internal_has_nose_tip();
}
inline void FaceKeypoints5::clear_nose_tip() {
  if (GetArenaForAllocation() == nullptr && _impl_.nose_tip_ != nullptr) {
    delete _impl_.nose_tip_;
  }
  _impl_.nose_tip_ = nullptr;
}
inline const ::face::Point2D& FaceKeypoints5::_internal_nose_tip() const {
  const ::face::Point2D* p = _impl_.nose_tip_;
  return p != nullptr ? *p : reinterpret_cast<const ::face::Point2D&>(
      ::face::_Point2D_default_instance_);
}
inline const ::face::Point2D& FaceKeypoints5::nose_tip() const {
  // @@protoc_insertion_point(field_get:face.FaceKeypoints5.nose_tip)
  return _internal_nose_tip();
}
inline void FaceKeypoints5::unsafe_arena_set_allocated_nose_tip(
    ::face::Point2D* nose_tip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nose_tip_);
  }
  _impl_.nose_tip_ = nose_tip;
  if (nose_tip) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:face.FaceKeypoints5.nose_tip)
}
inline ::face::Point2D* FaceKeypoints5::release_nose_tip() {
  
  ::face::Point2D* temp = _impl_.nose_tip_;
  _impl_.nose_tip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::face::Point2D* FaceKeypoints5::unsafe_arena_release_nose_tip() {
  // @@protoc_insertion_point(field_release:face.FaceKeypoints5.nose_tip)
  
  ::face::Point2D* temp = _impl_.nose_tip_;
  _impl_.nose_tip_ = nullptr;
  return temp;
}
inline ::face::Point2D* FaceKeypoints5::_internal_mutable_nose_tip() {
  
  if (_impl_.nose_tip_ == nullptr) {
    auto* p = CreateMaybeMessage<::face::Point2D>(GetArenaForAllocation());
    _impl_.nose_tip_ = p;
  }
  return _impl_.nose_tip_;
}
inline ::face::Point2D* FaceKeypoints5::mutable_nose_tip() {
  ::face::Point2D* _msg = _internal_mutable_nose_tip();
  // @@protoc_insertion_point(field_mutable:face.FaceKeypoints5.nose_tip)
  return _msg;
}
inline void FaceKeypoints5::set_allocated_nose_tip(::face::Point2D* nose_tip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.nose_tip_;
  }
  if (nose_tip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nose_tip);
    if (message_arena != submessage_arena) {
      nose_tip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nose_tip, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.nose_tip_ = nose_tip;
  // @@protoc_insertion_point(field_set_allocated:face.FaceKeypoints5.nose_tip)
}

// .face.Point2D mouth_left = 4;
inline bool FaceKeypoints5::_internal_has_mouth_left() const {
  return this != internal_default_instance() && _impl_.mouth_left_ != nullptr;
}
inline bool FaceKeypoints5::has_mouth_left() const {
  return _internal_has_mouth_left();
}
inline void FaceKeypoints5::clear_mouth_left() {
  if (GetArenaForAllocation() == nullptr && _impl_.mouth_left_ != nullptr) {
    delete _impl_.mouth_left_;
  }
  _impl_.mouth_left_ = nullptr;
}
inline const ::face::Point2D& FaceKeypoints5::_internal_mouth_left() const {
  const ::face::Point2D* p = _impl_.mouth_left_;
  return p != nullptr ? *p : reinterpret_cast<const ::face::Point2D&>(
      ::face::_Point2D_default_instance_);
}
inline const ::face::Point2D& FaceKeypoints5::mouth_left() const {
  // @@protoc_insertion_point(field_get:face.FaceKeypoints5.mouth_left)
  return _internal_mouth_left();
}
inline void FaceKeypoints5::unsafe_arena_set_allocated_mouth_left(
    ::face::Point2D* mouth_left) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mouth_left_);
  }
  _impl_.mouth_left_ = mouth_left;
  if (mouth_left) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:face.FaceKeypoints5.mouth_left)
}
inline ::face::Point2D* FaceKeypoints5::release_mouth_left() {
  
  ::face::Point2D* temp = _impl_.mouth_left_;
  _impl_.mouth_left_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::face::Point2D* FaceKeypoints5::unsafe_arena_release_mouth_left() {
  // @@protoc_insertion_point(field_release:face.FaceKeypoints5.mouth_left)
  
  ::face::Point2D* temp = _impl_.mouth_left_;
  _impl_.mouth_left_ = nullptr;
  return temp;
}
inline ::face::Point2D* FaceKeypoints5::_internal_mutable_mouth_left() {
  
  if (_impl_.mouth_left_ == nullptr) {
    auto* p = CreateMaybeMessage<::face::Point2D>(GetArenaForAllocation());
    _impl_.mouth_left_ = p;
  }
  return _impl_.mouth_left_;
}
inline ::face::Point2D* FaceKeypoints5::mutable_mouth_left() {
  ::face::Point2D* _msg = _internal_mutable_mouth_left();
  // @@protoc_insertion_point(field_mutable:face.FaceKeypoints5.mouth_left)
  return _msg;
}
inline void FaceKeypoints5::set_allocated_mouth_left(::face::Point2D* mouth_left) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.mouth_left_;
  }
  if (mouth_left) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mouth_left);
    if (message_arena != submessage_arena) {
      mouth_left = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mouth_left, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.mouth_left_ = mouth_left;
  // @@protoc_insertion_point(field_set_allocated:face.FaceKeypoints5.mouth_left)
}

// .face.Point2D mouth_right = 5;
inline bool FaceKeypoints5::_internal_has_mouth_right() const {
  return this != internal_default_instance() && _impl_.mouth_right_ != nullptr;
}
inline bool FaceKeypoints5::has_mouth_right() const {
  return _internal_has_mouth_right();
}
inline void FaceKeypoints5::clear_mouth_right() {
  if (GetArenaForAllocation() == nullptr && _impl_.mouth_right_ != nullptr) {
    delete _impl_.mouth_right_;
  }
  _impl_.mouth_right_ = nullptr;
}
inline const ::face::Point2D& FaceKeypoints5::_internal_mouth_right() const {
  const ::face::Point2D* p = _impl_.mouth_right_;
  return p != nullptr ? *p : reinterpret_cast<const ::face::Point2D&>(
      ::face::_Point2D_default_instance_);
}
inline const ::face::Point2D& FaceKeypoints5::mouth_right() const {
  // @@protoc_insertion_point(field_get:face.FaceKeypoints5.mouth_right)
  return _internal_mouth_right();
}
inline void FaceKeypoints5::unsafe_arena_set_allocated_mouth_right(
    ::face::Point2D* mouth_right) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mouth_right_);
  }
  _impl_.mouth_right_ = mouth_right;
  if (mouth_right) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:face.FaceKeypoints5.mouth_right)
}
inline ::face::Point2D* FaceKeypoints5::release_mouth_right() {
  
  ::face::Point2D* temp = _impl_.mouth_right_;
  _impl_.mouth_right_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::face::Point2D* FaceKeypoints5::unsafe_arena_release_mouth_right() {
  // @@protoc_insertion_point(field_release:face.FaceKeypoints5.mouth_right)
  
  ::face::Point2D* temp = _impl_.mouth_right_;
  _impl_.mouth_right_ = nullptr;
  return temp;
}
inline ::face::Point2D* FaceKeypoints5::_internal_mutable_mouth_right() {
  
  if (_impl_.mouth_right_ == nullptr) {
    auto* p = CreateMaybeMessage<::face::Point2D>(GetArenaForAllocation());
    _impl_.mouth_right_ = p;
  }
  return _impl_.mouth_right_;
}
inline ::face::Point2D* FaceKeypoints5::mutable_mouth_right() {
  ::face::Point2D* _msg = _internal_mutable_mouth_right();
  // @@protoc_insertion_point(field_mutable:face.FaceKeypoints5.mouth_right)
  return _msg;
}
inline void FaceKeypoints5::set_allocated_mouth_right(::face::Point2D* mouth_right) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.mouth_right_;
  }
  if (mouth_right) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mouth_right);
    if (message_arena != submessage_arena) {
      mouth_right = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mouth_right, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.mouth_right_ = mouth_right;
  // @@protoc_insertion_point(field_set_allocated:face.FaceKeypoints5.mouth_right)
}

// -------------------------------------------------------------------

// FaceKeypoints106

// repeated .face.Point2D points = 1;
inline int FaceKeypoints106::_internal_points_size() const {
  return _impl_.points_.size();
}
inline int FaceKeypoints106::points_size() const {
  return _internal_points_size();
}
inline void FaceKeypoints106::clear_points() {
  _impl_.points_.Clear();
}
inline ::face::Point2D* FaceKeypoints106::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:face.FaceKeypoints106.points)
  return _impl_.points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::face::Point2D >*
FaceKeypoints106::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:face.FaceKeypoints106.points)
  return &_impl_.points_;
}
inline const ::face::Point2D& FaceKeypoints106::_internal_points(int index) const {
  return _impl_.points_.Get(index);
}
inline const ::face::Point2D& FaceKeypoints106::points(int index) const {
  // @@protoc_insertion_point(field_get:face.FaceKeypoints106.points)
  return _internal_points(index);
}
inline ::face::Point2D* FaceKeypoints106::_internal_add_points() {
  return _impl_.points_.Add();
}
inline ::face::Point2D* FaceKeypoints106::add_points() {
  ::face::Point2D* _add = _internal_add_points();
  // @@protoc_insertion_point(field_add:face.FaceKeypoints106.points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::face::Point2D >&
FaceKeypoints106::points() const {
  // @@protoc_insertion_point(field_list:face.FaceKeypoints106.points)
  return _impl_.points_;
}

// -------------------------------------------------------------------

// FacePose

// float pitch = 1;
inline void FacePose::clear_pitch() {
  _impl_.pitch_ = 0;
}
inline float FacePose::_internal_pitch() const {
  return _impl_.pitch_;
}
inline float FacePose::pitch() const {
  // @@protoc_insertion_point(field_get:face.FacePose.pitch)
  return _internal_pitch();
}
inline void FacePose::_internal_set_pitch(float value) {
  
  _impl_.pitch_ = value;
}
inline void FacePose::set_pitch(float value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:face.FacePose.pitch)
}

// float yaw = 2;
inline void FacePose::clear_yaw() {
  _impl_.yaw_ = 0;
}
inline float FacePose::_internal_yaw() const {
  return _impl_.yaw_;
}
inline float FacePose::yaw() const {
  // @@protoc_insertion_point(field_get:face.FacePose.yaw)
  return _internal_yaw();
}
inline void FacePose::_internal_set_yaw(float value) {
  
  _impl_.yaw_ = value;
}
inline void FacePose::set_yaw(float value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:face.FacePose.yaw)
}

// float roll = 3;
inline void FacePose::clear_roll() {
  _impl_.roll_ = 0;
}
inline float FacePose::_internal_roll() const {
  return _impl_.roll_;
}
inline float FacePose::roll() const {
  // @@protoc_insertion_point(field_get:face.FacePose.roll)
  return _internal_roll();
}
inline void FacePose::_internal_set_roll(float value) {
  
  _impl_.roll_ = value;
}
inline void FacePose::set_roll(float value) {
  _internal_set_roll(value);
  // @@protoc_insertion_point(field_set:face.FacePose.roll)
}

// -------------------------------------------------------------------

// FaceAttributes

// float age = 1;
inline void FaceAttributes::clear_age() {
  _impl_.age_ = 0;
}
inline float FaceAttributes::_internal_age() const {
  return _impl_.age_;
}
inline float FaceAttributes::age() const {
  // @@protoc_insertion_point(field_get:face.FaceAttributes.age)
  return _internal_age();
}
inline void FaceAttributes::_internal_set_age(float value) {
  
  _impl_.age_ = value;
}
inline void FaceAttributes::set_age(float value) {
  _internal_set_age(value);
  // @@protoc_insertion_point(field_set:face.FaceAttributes.age)
}

// .face.FaceAttributes.Gender gender = 2;
inline void FaceAttributes::clear_gender() {
  _impl_.gender_ = 0;
}
inline ::face::FaceAttributes_Gender FaceAttributes::_internal_gender() const {
  return static_cast< ::face::FaceAttributes_Gender >(_impl_.gender_);
}
inline ::face::FaceAttributes_Gender FaceAttributes::gender() const {
  // @@protoc_insertion_point(field_get:face.FaceAttributes.gender)
  return _internal_gender();
}
inline void FaceAttributes::_internal_set_gender(::face::FaceAttributes_Gender value) {
  
  _impl_.gender_ = value;
}
inline void FaceAttributes::set_gender(::face::FaceAttributes_Gender value) {
  _internal_set_gender(value);
  // @@protoc_insertion_point(field_set:face.FaceAttributes.gender)
}

// -------------------------------------------------------------------

// FaceFeature

// repeated float vector = 1;
inline int FaceFeature::_internal_vector_size() const {
  return _impl_.vector_.size();
}
inline int FaceFeature::vector_size() const {
  return _internal_vector_size();
}
inline void FaceFeature::clear_vector() {
  _impl_.vector_.Clear();
}
inline float FaceFeature::_internal_vector(int index) const {
  return _impl_.vector_.Get(index);
}
inline float FaceFeature::vector(int index) const {
  // @@protoc_insertion_point(field_get:face.FaceFeature.vector)
  return _internal_vector(index);
}
inline void FaceFeature::set_vector(int index, float value) {
  _impl_.vector_.Set(index, value);
  // @@protoc_insertion_point(field_set:face.FaceFeature.vector)
}
inline void FaceFeature::_internal_add_vector(float value) {
  _impl_.vector_.Add(value);
}
inline void FaceFeature::add_vector(float value) {
  _internal_add_vector(value);
  // @@protoc_insertion_point(field_add:face.FaceFeature.vector)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
FaceFeature::_internal_vector() const {
  return _impl_.vector_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
FaceFeature::vector() const {
  // @@protoc_insertion_point(field_list:face.FaceFeature.vector)
  return _internal_vector();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
FaceFeature::_internal_mutable_vector() {
  return &_impl_.vector_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
FaceFeature::mutable_vector() {
  // @@protoc_insertion_point(field_mutable_list:face.FaceFeature.vector)
  return _internal_mutable_vector();
}

// string model_version = 2;
inline void FaceFeature::clear_model_version() {
  _impl_.model_version_.ClearToEmpty();
}
inline const std::string& FaceFeature::model_version() const {
  // @@protoc_insertion_point(field_get:face.FaceFeature.model_version)
  return _internal_model_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FaceFeature::set_model_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:face.FaceFeature.model_version)
}
inline std::string* FaceFeature::mutable_model_version() {
  std::string* _s = _internal_mutable_model_version();
  // @@protoc_insertion_point(field_mutable:face.FaceFeature.model_version)
  return _s;
}
inline const std::string& FaceFeature::_internal_model_version() const {
  return _impl_.model_version_.Get();
}
inline void FaceFeature::_internal_set_model_version(const std::string& value) {
  
  _impl_.model_version_.Set(value, GetArenaForAllocation());
}
inline std::string* FaceFeature::_internal_mutable_model_version() {
  
  return _impl_.model_version_.Mutable(GetArenaForAllocation());
}
inline std::string* FaceFeature::release_model_version() {
  // @@protoc_insertion_point(field_release:face.FaceFeature.model_version)
  return _impl_.model_version_.Release();
}
inline void FaceFeature::set_allocated_model_version(std::string* model_version) {
  if (model_version != nullptr) {
    
  } else {
    
  }
  _impl_.model_version_.SetAllocated(model_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_version_.IsDefault()) {
    _impl_.model_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:face.FaceFeature.model_version)
}

// -------------------------------------------------------------------

// FaceRecognitionResult

// string face_id = 1;
inline void FaceRecognitionResult::clear_face_id() {
  _impl_.face_id_.ClearToEmpty();
}
inline const std::string& FaceRecognitionResult::face_id() const {
  // @@protoc_insertion_point(field_get:face.FaceRecognitionResult.face_id)
  return _internal_face_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FaceRecognitionResult::set_face_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.face_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:face.FaceRecognitionResult.face_id)
}
inline std::string* FaceRecognitionResult::mutable_face_id() {
  std::string* _s = _internal_mutable_face_id();
  // @@protoc_insertion_point(field_mutable:face.FaceRecognitionResult.face_id)
  return _s;
}
inline const std::string& FaceRecognitionResult::_internal_face_id() const {
  return _impl_.face_id_.Get();
}
inline void FaceRecognitionResult::_internal_set_face_id(const std::string& value) {
  
  _impl_.face_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FaceRecognitionResult::_internal_mutable_face_id() {
  
  return _impl_.face_id_.Mutable(GetArenaForAllocation());
}
inline std::string* FaceRecognitionResult::release_face_id() {
  // @@protoc_insertion_point(field_release:face.FaceRecognitionResult.face_id)
  return _impl_.face_id_.Release();
}
inline void FaceRecognitionResult::set_allocated_face_id(std::string* face_id) {
  if (face_id != nullptr) {
    
  } else {
    
  }
  _impl_.face_id_.SetAllocated(face_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.face_id_.IsDefault()) {
    _impl_.face_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:face.FaceRecognitionResult.face_id)
}

// float similarity = 3;
inline void FaceRecognitionResult::clear_similarity() {
  _impl_.similarity_ = 0;
}
inline float FaceRecognitionResult::_internal_similarity() const {
  return _impl_.similarity_;
}
inline float FaceRecognitionResult::similarity() const {
  // @@protoc_insertion_point(field_get:face.FaceRecognitionResult.similarity)
  return _internal_similarity();
}
inline void FaceRecognitionResult::_internal_set_similarity(float value) {
  
  _impl_.similarity_ = value;
}
inline void FaceRecognitionResult::set_similarity(float value) {
  _internal_set_similarity(value);
  // @@protoc_insertion_point(field_set:face.FaceRecognitionResult.similarity)
}

// -------------------------------------------------------------------

// Face

// string image_id = 1;
inline void Face::clear_image_id() {
  _impl_.image_id_.ClearToEmpty();
}
inline const std::string& Face::image_id() const {
  // @@protoc_insertion_point(field_get:face.Face.image_id)
  return _internal_image_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Face::set_image_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.image_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:face.Face.image_id)
}
inline std::string* Face::mutable_image_id() {
  std::string* _s = _internal_mutable_image_id();
  // @@protoc_insertion_point(field_mutable:face.Face.image_id)
  return _s;
}
inline const std::string& Face::_internal_image_id() const {
  return _impl_.image_id_.Get();
}
inline void Face::_internal_set_image_id(const std::string& value) {
  
  _impl_.image_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Face::_internal_mutable_image_id() {
  
  return _impl_.image_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Face::release_image_id() {
  // @@protoc_insertion_point(field_release:face.Face.image_id)
  return _impl_.image_id_.Release();
}
inline void Face::set_allocated_image_id(std::string* image_id) {
  if (image_id != nullptr) {
    
  } else {
    
  }
  _impl_.image_id_.SetAllocated(image_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.image_id_.IsDefault()) {
    _impl_.image_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:face.Face.image_id)
}

// int32 face_index = 2;
inline void Face::clear_face_index() {
  _impl_.face_index_ = 0;
}
inline int32_t Face::_internal_face_index() const {
  return _impl_.face_index_;
}
inline int32_t Face::face_index() const {
  // @@protoc_insertion_point(field_get:face.Face.face_index)
  return _internal_face_index();
}
inline void Face::_internal_set_face_index(int32_t value) {
  
  _impl_.face_index_ = value;
}
inline void Face::set_face_index(int32_t value) {
  _internal_set_face_index(value);
  // @@protoc_insertion_point(field_set:face.Face.face_index)
}

// .face.FaceBox box = 3;
inline bool Face::_internal_has_box() const {
  return this != internal_default_instance() && _impl_.box_ != nullptr;
}
inline bool Face::has_box() const {
  return _internal_has_box();
}
inline void Face::clear_box() {
  if (GetArenaForAllocation() == nullptr && _impl_.box_ != nullptr) {
    delete _impl_.box_;
  }
  _impl_.box_ = nullptr;
}
inline const ::face::FaceBox& Face::_internal_box() const {
  const ::face::FaceBox* p = _impl_.box_;
  return p != nullptr ? *p : reinterpret_cast<const ::face::FaceBox&>(
      ::face::_FaceBox_default_instance_);
}
inline const ::face::FaceBox& Face::box() const {
  // @@protoc_insertion_point(field_get:face.Face.box)
  return _internal_box();
}
inline void Face::unsafe_arena_set_allocated_box(
    ::face::FaceBox* box) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.box_);
  }
  _impl_.box_ = box;
  if (box) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:face.Face.box)
}
inline ::face::FaceBox* Face::release_box() {
  
  ::face::FaceBox* temp = _impl_.box_;
  _impl_.box_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::face::FaceBox* Face::unsafe_arena_release_box() {
  // @@protoc_insertion_point(field_release:face.Face.box)
  
  ::face::FaceBox* temp = _impl_.box_;
  _impl_.box_ = nullptr;
  return temp;
}
inline ::face::FaceBox* Face::_internal_mutable_box() {
  
  if (_impl_.box_ == nullptr) {
    auto* p = CreateMaybeMessage<::face::FaceBox>(GetArenaForAllocation());
    _impl_.box_ = p;
  }
  return _impl_.box_;
}
inline ::face::FaceBox* Face::mutable_box() {
  ::face::FaceBox* _msg = _internal_mutable_box();
  // @@protoc_insertion_point(field_mutable:face.Face.box)
  return _msg;
}
inline void Face::set_allocated_box(::face::FaceBox* box) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.box_;
  }
  if (box) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(box);
    if (message_arena != submessage_arena) {
      box = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, box, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.box_ = box;
  // @@protoc_insertion_point(field_set_allocated:face.Face.box)
}

// .face.FaceKeypoints5 keypoints5 = 4;
inline bool Face::_internal_has_keypoints5() const {
  return this != internal_default_instance() && _impl_.keypoints5_ != nullptr;
}
inline bool Face::has_keypoints5() const {
  return _internal_has_keypoints5();
}
inline void Face::clear_keypoints5() {
  if (GetArenaForAllocation() == nullptr && _impl_.keypoints5_ != nullptr) {
    delete _impl_.keypoints5_;
  }
  _impl_.keypoints5_ = nullptr;
}
inline const ::face::FaceKeypoints5& Face::_internal_keypoints5() const {
  const ::face::FaceKeypoints5* p = _impl_.keypoints5_;
  return p != nullptr ? *p : reinterpret_cast<const ::face::FaceKeypoints5&>(
      ::face::_FaceKeypoints5_default_instance_);
}
inline const ::face::FaceKeypoints5& Face::keypoints5() const {
  // @@protoc_insertion_point(field_get:face.Face.keypoints5)
  return _internal_keypoints5();
}
inline void Face::unsafe_arena_set_allocated_keypoints5(
    ::face::FaceKeypoints5* keypoints5) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.keypoints5_);
  }
  _impl_.keypoints5_ = keypoints5;
  if (keypoints5) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:face.Face.keypoints5)
}
inline ::face::FaceKeypoints5* Face::release_keypoints5() {
  
  ::face::FaceKeypoints5* temp = _impl_.keypoints5_;
  _impl_.keypoints5_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::face::FaceKeypoints5* Face::unsafe_arena_release_keypoints5() {
  // @@protoc_insertion_point(field_release:face.Face.keypoints5)
  
  ::face::FaceKeypoints5* temp = _impl_.keypoints5_;
  _impl_.keypoints5_ = nullptr;
  return temp;
}
inline ::face::FaceKeypoints5* Face::_internal_mutable_keypoints5() {
  
  if (_impl_.keypoints5_ == nullptr) {
    auto* p = CreateMaybeMessage<::face::FaceKeypoints5>(GetArenaForAllocation());
    _impl_.keypoints5_ = p;
  }
  return _impl_.keypoints5_;
}
inline ::face::FaceKeypoints5* Face::mutable_keypoints5() {
  ::face::FaceKeypoints5* _msg = _internal_mutable_keypoints5();
  // @@protoc_insertion_point(field_mutable:face.Face.keypoints5)
  return _msg;
}
inline void Face::set_allocated_keypoints5(::face::FaceKeypoints5* keypoints5) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.keypoints5_;
  }
  if (keypoints5) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(keypoints5);
    if (message_arena != submessage_arena) {
      keypoints5 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, keypoints5, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.keypoints5_ = keypoints5;
  // @@protoc_insertion_point(field_set_allocated:face.Face.keypoints5)
}

// .face.FaceKeypoints106 keypoints106 = 5;
inline bool Face::_internal_has_keypoints106() const {
  return this != internal_default_instance() && _impl_.keypoints106_ != nullptr;
}
inline bool Face::has_keypoints106() const {
  return _internal_has_keypoints106();
}
inline void Face::clear_keypoints106() {
  if (GetArenaForAllocation() == nullptr && _impl_.keypoints106_ != nullptr) {
    delete _impl_.keypoints106_;
  }
  _impl_.keypoints106_ = nullptr;
}
inline const ::face::FaceKeypoints106& Face::_internal_keypoints106() const {
  const ::face::FaceKeypoints106* p = _impl_.keypoints106_;
  return p != nullptr ? *p : reinterpret_cast<const ::face::FaceKeypoints106&>(
      ::face::_FaceKeypoints106_default_instance_);
}
inline const ::face::FaceKeypoints106& Face::keypoints106() const {
  // @@protoc_insertion_point(field_get:face.Face.keypoints106)
  return _internal_keypoints106();
}
inline void Face::unsafe_arena_set_allocated_keypoints106(
    ::face::FaceKeypoints106* keypoints106) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.keypoints106_);
  }
  _impl_.keypoints106_ = keypoints106;
  if (keypoints106) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:face.Face.keypoints106)
}
inline ::face::FaceKeypoints106* Face::release_keypoints106() {
  
  ::face::FaceKeypoints106* temp = _impl_.keypoints106_;
  _impl_.keypoints106_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::face::FaceKeypoints106* Face::unsafe_arena_release_keypoints106() {
  // @@protoc_insertion_point(field_release:face.Face.keypoints106)
  
  ::face::FaceKeypoints106* temp = _impl_.keypoints106_;
  _impl_.keypoints106_ = nullptr;
  return temp;
}
inline ::face::FaceKeypoints106* Face::_internal_mutable_keypoints106() {
  
  if (_impl_.keypoints106_ == nullptr) {
    auto* p = CreateMaybeMessage<::face::FaceKeypoints106>(GetArenaForAllocation());
    _impl_.keypoints106_ = p;
  }
  return _impl_.keypoints106_;
}
inline ::face::FaceKeypoints106* Face::mutable_keypoints106() {
  ::face::FaceKeypoints106* _msg = _internal_mutable_keypoints106();
  // @@protoc_insertion_point(field_mutable:face.Face.keypoints106)
  return _msg;
}
inline void Face::set_allocated_keypoints106(::face::FaceKeypoints106* keypoints106) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.keypoints106_;
  }
  if (keypoints106) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(keypoints106);
    if (message_arena != submessage_arena) {
      keypoints106 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, keypoints106, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.keypoints106_ = keypoints106;
  // @@protoc_insertion_point(field_set_allocated:face.Face.keypoints106)
}

// .face.FacePose pose = 6;
inline bool Face::_internal_has_pose() const {
  return this != internal_default_instance() && _impl_.pose_ != nullptr;
}
inline bool Face::has_pose() const {
  return _internal_has_pose();
}
inline void Face::clear_pose() {
  if (GetArenaForAllocation() == nullptr && _impl_.pose_ != nullptr) {
    delete _impl_.pose_;
  }
  _impl_.pose_ = nullptr;
}
inline const ::face::FacePose& Face::_internal_pose() const {
  const ::face::FacePose* p = _impl_.pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::face::FacePose&>(
      ::face::_FacePose_default_instance_);
}
inline const ::face::FacePose& Face::pose() const {
  // @@protoc_insertion_point(field_get:face.Face.pose)
  return _internal_pose();
}
inline void Face::unsafe_arena_set_allocated_pose(
    ::face::FacePose* pose) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pose_);
  }
  _impl_.pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:face.Face.pose)
}
inline ::face::FacePose* Face::release_pose() {
  
  ::face::FacePose* temp = _impl_.pose_;
  _impl_.pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::face::FacePose* Face::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_release:face.Face.pose)
  
  ::face::FacePose* temp = _impl_.pose_;
  _impl_.pose_ = nullptr;
  return temp;
}
inline ::face::FacePose* Face::_internal_mutable_pose() {
  
  if (_impl_.pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::face::FacePose>(GetArenaForAllocation());
    _impl_.pose_ = p;
  }
  return _impl_.pose_;
}
inline ::face::FacePose* Face::mutable_pose() {
  ::face::FacePose* _msg = _internal_mutable_pose();
  // @@protoc_insertion_point(field_mutable:face.Face.pose)
  return _msg;
}
inline void Face::set_allocated_pose(::face::FacePose* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pose_;
  }
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pose);
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:face.Face.pose)
}

// .face.FaceAttributes attributes = 7;
inline bool Face::_internal_has_attributes() const {
  return this != internal_default_instance() && _impl_.attributes_ != nullptr;
}
inline bool Face::has_attributes() const {
  return _internal_has_attributes();
}
inline void Face::clear_attributes() {
  if (GetArenaForAllocation() == nullptr && _impl_.attributes_ != nullptr) {
    delete _impl_.attributes_;
  }
  _impl_.attributes_ = nullptr;
}
inline const ::face::FaceAttributes& Face::_internal_attributes() const {
  const ::face::FaceAttributes* p = _impl_.attributes_;
  return p != nullptr ? *p : reinterpret_cast<const ::face::FaceAttributes&>(
      ::face::_FaceAttributes_default_instance_);
}
inline const ::face::FaceAttributes& Face::attributes() const {
  // @@protoc_insertion_point(field_get:face.Face.attributes)
  return _internal_attributes();
}
inline void Face::unsafe_arena_set_allocated_attributes(
    ::face::FaceAttributes* attributes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.attributes_);
  }
  _impl_.attributes_ = attributes;
  if (attributes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:face.Face.attributes)
}
inline ::face::FaceAttributes* Face::release_attributes() {
  
  ::face::FaceAttributes* temp = _impl_.attributes_;
  _impl_.attributes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::face::FaceAttributes* Face::unsafe_arena_release_attributes() {
  // @@protoc_insertion_point(field_release:face.Face.attributes)
  
  ::face::FaceAttributes* temp = _impl_.attributes_;
  _impl_.attributes_ = nullptr;
  return temp;
}
inline ::face::FaceAttributes* Face::_internal_mutable_attributes() {
  
  if (_impl_.attributes_ == nullptr) {
    auto* p = CreateMaybeMessage<::face::FaceAttributes>(GetArenaForAllocation());
    _impl_.attributes_ = p;
  }
  return _impl_.attributes_;
}
inline ::face::FaceAttributes* Face::mutable_attributes() {
  ::face::FaceAttributes* _msg = _internal_mutable_attributes();
  // @@protoc_insertion_point(field_mutable:face.Face.attributes)
  return _msg;
}
inline void Face::set_allocated_attributes(::face::FaceAttributes* attributes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.attributes_;
  }
  if (attributes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(attributes);
    if (message_arena != submessage_arena) {
      attributes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attributes, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.attributes_ = attributes;
  // @@protoc_insertion_point(field_set_allocated:face.Face.attributes)
}

// .face.FaceFeature feature = 8;
inline bool Face::_internal_has_feature() const {
  return this != internal_default_instance() && _impl_.feature_ != nullptr;
}
inline bool Face::has_feature() const {
  return _internal_has_feature();
}
inline void Face::clear_feature() {
  if (GetArenaForAllocation() == nullptr && _impl_.feature_ != nullptr) {
    delete _impl_.feature_;
  }
  _impl_.feature_ = nullptr;
}
inline const ::face::FaceFeature& Face::_internal_feature() const {
  const ::face::FaceFeature* p = _impl_.feature_;
  return p != nullptr ? *p : reinterpret_cast<const ::face::FaceFeature&>(
      ::face::_FaceFeature_default_instance_);
}
inline const ::face::FaceFeature& Face::feature() const {
  // @@protoc_insertion_point(field_get:face.Face.feature)
  return _internal_feature();
}
inline void Face::unsafe_arena_set_allocated_feature(
    ::face::FaceFeature* feature) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.feature_);
  }
  _impl_.feature_ = feature;
  if (feature) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:face.Face.feature)
}
inline ::face::FaceFeature* Face::release_feature() {
  
  ::face::FaceFeature* temp = _impl_.feature_;
  _impl_.feature_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::face::FaceFeature* Face::unsafe_arena_release_feature() {
  // @@protoc_insertion_point(field_release:face.Face.feature)
  
  ::face::FaceFeature* temp = _impl_.feature_;
  _impl_.feature_ = nullptr;
  return temp;
}
inline ::face::FaceFeature* Face::_internal_mutable_feature() {
  
  if (_impl_.feature_ == nullptr) {
    auto* p = CreateMaybeMessage<::face::FaceFeature>(GetArenaForAllocation());
    _impl_.feature_ = p;
  }
  return _impl_.feature_;
}
inline ::face::FaceFeature* Face::mutable_feature() {
  ::face::FaceFeature* _msg = _internal_mutable_feature();
  // @@protoc_insertion_point(field_mutable:face.Face.feature)
  return _msg;
}
inline void Face::set_allocated_feature(::face::FaceFeature* feature) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.feature_;
  }
  if (feature) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(feature);
    if (message_arena != submessage_arena) {
      feature = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, feature, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.feature_ = feature;
  // @@protoc_insertion_point(field_set_allocated:face.Face.feature)
}

// .face.FaceRecognitionResult recognition = 9;
inline bool Face::_internal_has_recognition() const {
  return this != internal_default_instance() && _impl_.recognition_ != nullptr;
}
inline bool Face::has_recognition() const {
  return _internal_has_recognition();
}
inline void Face::clear_recognition() {
  if (GetArenaForAllocation() == nullptr && _impl_.recognition_ != nullptr) {
    delete _impl_.recognition_;
  }
  _impl_.recognition_ = nullptr;
}
inline const ::face::FaceRecognitionResult& Face::_internal_recognition() const {
  const ::face::FaceRecognitionResult* p = _impl_.recognition_;
  return p != nullptr ? *p : reinterpret_cast<const ::face::FaceRecognitionResult&>(
      ::face::_FaceRecognitionResult_default_instance_);
}
inline const ::face::FaceRecognitionResult& Face::recognition() const {
  // @@protoc_insertion_point(field_get:face.Face.recognition)
  return _internal_recognition();
}
inline void Face::unsafe_arena_set_allocated_recognition(
    ::face::FaceRecognitionResult* recognition) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.recognition_);
  }
  _impl_.recognition_ = recognition;
  if (recognition) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:face.Face.recognition)
}
inline ::face::FaceRecognitionResult* Face::release_recognition() {
  
  ::face::FaceRecognitionResult* temp = _impl_.recognition_;
  _impl_.recognition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::face::FaceRecognitionResult* Face::unsafe_arena_release_recognition() {
  // @@protoc_insertion_point(field_release:face.Face.recognition)
  
  ::face::FaceRecognitionResult* temp = _impl_.recognition_;
  _impl_.recognition_ = nullptr;
  return temp;
}
inline ::face::FaceRecognitionResult* Face::_internal_mutable_recognition() {
  
  if (_impl_.recognition_ == nullptr) {
    auto* p = CreateMaybeMessage<::face::FaceRecognitionResult>(GetArenaForAllocation());
    _impl_.recognition_ = p;
  }
  return _impl_.recognition_;
}
inline ::face::FaceRecognitionResult* Face::mutable_recognition() {
  ::face::FaceRecognitionResult* _msg = _internal_mutable_recognition();
  // @@protoc_insertion_point(field_mutable:face.Face.recognition)
  return _msg;
}
inline void Face::set_allocated_recognition(::face::FaceRecognitionResult* recognition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.recognition_;
  }
  if (recognition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(recognition);
    if (message_arena != submessage_arena) {
      recognition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, recognition, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.recognition_ = recognition;
  // @@protoc_insertion_point(field_set_allocated:face.Face.recognition)
}

// int64 timestamp = 10;
inline void Face::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
}
inline int64_t Face::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t Face::timestamp() const {
  // @@protoc_insertion_point(field_get:face.Face.timestamp)
  return _internal_timestamp();
}
inline void Face::_internal_set_timestamp(int64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void Face::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:face.Face.timestamp)
}

// -------------------------------------------------------------------

// FaceRecord

// string face_id = 1;
inline void FaceRecord::clear_face_id() {
  _impl_.face_id_.ClearToEmpty();
}
inline const std::string& FaceRecord::face_id() const {
  // @@protoc_insertion_point(field_get:face.FaceRecord.face_id)
  return _internal_face_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FaceRecord::set_face_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.face_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:face.FaceRecord.face_id)
}
inline std::string* FaceRecord::mutable_face_id() {
  std::string* _s = _internal_mutable_face_id();
  // @@protoc_insertion_point(field_mutable:face.FaceRecord.face_id)
  return _s;
}
inline const std::string& FaceRecord::_internal_face_id() const {
  return _impl_.face_id_.Get();
}
inline void FaceRecord::_internal_set_face_id(const std::string& value) {
  
  _impl_.face_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FaceRecord::_internal_mutable_face_id() {
  
  return _impl_.face_id_.Mutable(GetArenaForAllocation());
}
inline std::string* FaceRecord::release_face_id() {
  // @@protoc_insertion_point(field_release:face.FaceRecord.face_id)
  return _impl_.face_id_.Release();
}
inline void FaceRecord::set_allocated_face_id(std::string* face_id) {
  if (face_id != nullptr) {
    
  } else {
    
  }
  _impl_.face_id_.SetAllocated(face_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.face_id_.IsDefault()) {
    _impl_.face_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:face.FaceRecord.face_id)
}

// string person_id = 2;
inline void FaceRecord::clear_person_id() {
  _impl_.person_id_.ClearToEmpty();
}
inline const std::string& FaceRecord::person_id() const {
  // @@protoc_insertion_point(field_get:face.FaceRecord.person_id)
  return _internal_person_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FaceRecord::set_person_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.person_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:face.FaceRecord.person_id)
}
inline std::string* FaceRecord::mutable_person_id() {
  std::string* _s = _internal_mutable_person_id();
  // @@protoc_insertion_point(field_mutable:face.FaceRecord.person_id)
  return _s;
}
inline const std::string& FaceRecord::_internal_person_id() const {
  return _impl_.person_id_.Get();
}
inline void FaceRecord::_internal_set_person_id(const std::string& value) {
  
  _impl_.person_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FaceRecord::_internal_mutable_person_id() {
  
  return _impl_.person_id_.Mutable(GetArenaForAllocation());
}
inline std::string* FaceRecord::release_person_id() {
  // @@protoc_insertion_point(field_release:face.FaceRecord.person_id)
  return _impl_.person_id_.Release();
}
inline void FaceRecord::set_allocated_person_id(std::string* person_id) {
  if (person_id != nullptr) {
    
  } else {
    
  }
  _impl_.person_id_.SetAllocated(person_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.person_id_.IsDefault()) {
    _impl_.person_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:face.FaceRecord.person_id)
}

// string name = 3;
inline void FaceRecord::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& FaceRecord::name() const {
  // @@protoc_insertion_point(field_get:face.FaceRecord.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FaceRecord::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:face.FaceRecord.name)
}
inline std::string* FaceRecord::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:face.FaceRecord.name)
  return _s;
}
inline const std::string& FaceRecord::_internal_name() const {
  return _impl_.name_.Get();
}
inline void FaceRecord::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* FaceRecord::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* FaceRecord::release_name() {
  // @@protoc_insertion_point(field_release:face.FaceRecord.name)
  return _impl_.name_.Release();
}
inline void FaceRecord::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:face.FaceRecord.name)
}

// .face.FaceFeature feature = 4;
inline bool FaceRecord::_internal_has_feature() const {
  return this != internal_default_instance() && _impl_.feature_ != nullptr;
}
inline bool FaceRecord::has_feature() const {
  return _internal_has_feature();
}
inline void FaceRecord::clear_feature() {
  if (GetArenaForAllocation() == nullptr && _impl_.feature_ != nullptr) {
    delete _impl_.feature_;
  }
  _impl_.feature_ = nullptr;
}
inline const ::face::FaceFeature& FaceRecord::_internal_feature() const {
  const ::face::FaceFeature* p = _impl_.feature_;
  return p != nullptr ? *p : reinterpret_cast<const ::face::FaceFeature&>(
      ::face::_FaceFeature_default_instance_);
}
inline const ::face::FaceFeature& FaceRecord::feature() const {
  // @@protoc_insertion_point(field_get:face.FaceRecord.feature)
  return _internal_feature();
}
inline void FaceRecord::unsafe_arena_set_allocated_feature(
    ::face::FaceFeature* feature) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.feature_);
  }
  _impl_.feature_ = feature;
  if (feature) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:face.FaceRecord.feature)
}
inline ::face::FaceFeature* FaceRecord::release_feature() {
  
  ::face::FaceFeature* temp = _impl_.feature_;
  _impl_.feature_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::face::FaceFeature* FaceRecord::unsafe_arena_release_feature() {
  // @@protoc_insertion_point(field_release:face.FaceRecord.feature)
  
  ::face::FaceFeature* temp = _impl_.feature_;
  _impl_.feature_ = nullptr;
  return temp;
}
inline ::face::FaceFeature* FaceRecord::_internal_mutable_feature() {
  
  if (_impl_.feature_ == nullptr) {
    auto* p = CreateMaybeMessage<::face::FaceFeature>(GetArenaForAllocation());
    _impl_.feature_ = p;
  }
  return _impl_.feature_;
}
inline ::face::FaceFeature* FaceRecord::mutable_feature() {
  ::face::FaceFeature* _msg = _internal_mutable_feature();
  // @@protoc_insertion_point(field_mutable:face.FaceRecord.feature)
  return _msg;
}
inline void FaceRecord::set_allocated_feature(::face::FaceFeature* feature) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.feature_;
  }
  if (feature) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(feature);
    if (message_arena != submessage_arena) {
      feature = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, feature, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.feature_ = feature;
  // @@protoc_insertion_point(field_set_allocated:face.FaceRecord.feature)
}

// bytes face_image = 5;
inline void FaceRecord::clear_face_image() {
  _impl_.face_image_.ClearToEmpty();
}
inline const std::string& FaceRecord::face_image() const {
  // @@protoc_insertion_point(field_get:face.FaceRecord.face_image)
  return _internal_face_image();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FaceRecord::set_face_image(ArgT0&& arg0, ArgT... args) {
 
 _impl_.face_image_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:face.FaceRecord.face_image)
}
inline std::string* FaceRecord::mutable_face_image() {
  std::string* _s = _internal_mutable_face_image();
  // @@protoc_insertion_point(field_mutable:face.FaceRecord.face_image)
  return _s;
}
inline const std::string& FaceRecord::_internal_face_image() const {
  return _impl_.face_image_.Get();
}
inline void FaceRecord::_internal_set_face_image(const std::string& value) {
  
  _impl_.face_image_.Set(value, GetArenaForAllocation());
}
inline std::string* FaceRecord::_internal_mutable_face_image() {
  
  return _impl_.face_image_.Mutable(GetArenaForAllocation());
}
inline std::string* FaceRecord::release_face_image() {
  // @@protoc_insertion_point(field_release:face.FaceRecord.face_image)
  return _impl_.face_image_.Release();
}
inline void FaceRecord::set_allocated_face_image(std::string* face_image) {
  if (face_image != nullptr) {
    
  } else {
    
  }
  _impl_.face_image_.SetAllocated(face_image, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.face_image_.IsDefault()) {
    _impl_.face_image_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:face.FaceRecord.face_image)
}

// int64 create_time = 6;
inline void FaceRecord::clear_create_time() {
  _impl_.create_time_ = int64_t{0};
}
inline int64_t FaceRecord::_internal_create_time() const {
  return _impl_.create_time_;
}
inline int64_t FaceRecord::create_time() const {
  // @@protoc_insertion_point(field_get:face.FaceRecord.create_time)
  return _internal_create_time();
}
inline void FaceRecord::_internal_set_create_time(int64_t value) {
  
  _impl_.create_time_ = value;
}
inline void FaceRecord::set_create_time(int64_t value) {
  _internal_set_create_time(value);
  // @@protoc_insertion_point(field_set:face.FaceRecord.create_time)
}

// int64 update_time = 7;
inline void FaceRecord::clear_update_time() {
  _impl_.update_time_ = int64_t{0};
}
inline int64_t FaceRecord::_internal_update_time() const {
  return _impl_.update_time_;
}
inline int64_t FaceRecord::update_time() const {
  // @@protoc_insertion_point(field_get:face.FaceRecord.update_time)
  return _internal_update_time();
}
inline void FaceRecord::_internal_set_update_time(int64_t value) {
  
  _impl_.update_time_ = value;
}
inline void FaceRecord::set_update_time(int64_t value) {
  _internal_set_update_time(value);
  // @@protoc_insertion_point(field_set:face.FaceRecord.update_time)
}

// -------------------------------------------------------------------

// FaceDetectionRequest

// bytes image = 1;
inline void FaceDetectionRequest::clear_image() {
  _impl_.image_.ClearToEmpty();
}
inline const std::string& FaceDetectionRequest::image() const {
  // @@protoc_insertion_point(field_get:face.FaceDetectionRequest.image)
  return _internal_image();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FaceDetectionRequest::set_image(ArgT0&& arg0, ArgT... args) {
 
 _impl_.image_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:face.FaceDetectionRequest.image)
}
inline std::string* FaceDetectionRequest::mutable_image() {
  std::string* _s = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:face.FaceDetectionRequest.image)
  return _s;
}
inline const std::string& FaceDetectionRequest::_internal_image() const {
  return _impl_.image_.Get();
}
inline void FaceDetectionRequest::_internal_set_image(const std::string& value) {
  
  _impl_.image_.Set(value, GetArenaForAllocation());
}
inline std::string* FaceDetectionRequest::_internal_mutable_image() {
  
  return _impl_.image_.Mutable(GetArenaForAllocation());
}
inline std::string* FaceDetectionRequest::release_image() {
  // @@protoc_insertion_point(field_release:face.FaceDetectionRequest.image)
  return _impl_.image_.Release();
}
inline void FaceDetectionRequest::set_allocated_image(std::string* image) {
  if (image != nullptr) {
    
  } else {
    
  }
  _impl_.image_.SetAllocated(image, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.image_.IsDefault()) {
    _impl_.image_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:face.FaceDetectionRequest.image)
}

// bool extract_keypoints5 = 2;
inline void FaceDetectionRequest::clear_extract_keypoints5() {
  _impl_.extract_keypoints5_ = false;
}
inline bool FaceDetectionRequest::_internal_extract_keypoints5() const {
  return _impl_.extract_keypoints5_;
}
inline bool FaceDetectionRequest::extract_keypoints5() const {
  // @@protoc_insertion_point(field_get:face.FaceDetectionRequest.extract_keypoints5)
  return _internal_extract_keypoints5();
}
inline void FaceDetectionRequest::_internal_set_extract_keypoints5(bool value) {
  
  _impl_.extract_keypoints5_ = value;
}
inline void FaceDetectionRequest::set_extract_keypoints5(bool value) {
  _internal_set_extract_keypoints5(value);
  // @@protoc_insertion_point(field_set:face.FaceDetectionRequest.extract_keypoints5)
}

// bool extract_keypoints106 = 3;
inline void FaceDetectionRequest::clear_extract_keypoints106() {
  _impl_.extract_keypoints106_ = false;
}
inline bool FaceDetectionRequest::_internal_extract_keypoints106() const {
  return _impl_.extract_keypoints106_;
}
inline bool FaceDetectionRequest::extract_keypoints106() const {
  // @@protoc_insertion_point(field_get:face.FaceDetectionRequest.extract_keypoints106)
  return _internal_extract_keypoints106();
}
inline void FaceDetectionRequest::_internal_set_extract_keypoints106(bool value) {
  
  _impl_.extract_keypoints106_ = value;
}
inline void FaceDetectionRequest::set_extract_keypoints106(bool value) {
  _internal_set_extract_keypoints106(value);
  // @@protoc_insertion_point(field_set:face.FaceDetectionRequest.extract_keypoints106)
}

// bool extract_attributes = 4;
inline void FaceDetectionRequest::clear_extract_attributes() {
  _impl_.extract_attributes_ = false;
}
inline bool FaceDetectionRequest::_internal_extract_attributes() const {
  return _impl_.extract_attributes_;
}
inline bool FaceDetectionRequest::extract_attributes() const {
  // @@protoc_insertion_point(field_get:face.FaceDetectionRequest.extract_attributes)
  return _internal_extract_attributes();
}
inline void FaceDetectionRequest::_internal_set_extract_attributes(bool value) {
  
  _impl_.extract_attributes_ = value;
}
inline void FaceDetectionRequest::set_extract_attributes(bool value) {
  _internal_set_extract_attributes(value);
  // @@protoc_insertion_point(field_set:face.FaceDetectionRequest.extract_attributes)
}

// bool extract_feature = 5;
inline void FaceDetectionRequest::clear_extract_feature() {
  _impl_.extract_feature_ = false;
}
inline bool FaceDetectionRequest::_internal_extract_feature() const {
  return _impl_.extract_feature_;
}
inline bool FaceDetectionRequest::extract_feature() const {
  // @@protoc_insertion_point(field_get:face.FaceDetectionRequest.extract_feature)
  return _internal_extract_feature();
}
inline void FaceDetectionRequest::_internal_set_extract_feature(bool value) {
  
  _impl_.extract_feature_ = value;
}
inline void FaceDetectionRequest::set_extract_feature(bool value) {
  _internal_set_extract_feature(value);
  // @@protoc_insertion_point(field_set:face.FaceDetectionRequest.extract_feature)
}

// -------------------------------------------------------------------

// FaceDetectionResponse

// repeated .face.Face faces = 1;
inline int FaceDetectionResponse::_internal_faces_size() const {
  return _impl_.faces_.size();
}
inline int FaceDetectionResponse::faces_size() const {
  return _internal_faces_size();
}
inline void FaceDetectionResponse::clear_faces() {
  _impl_.faces_.Clear();
}
inline ::face::Face* FaceDetectionResponse::mutable_faces(int index) {
  // @@protoc_insertion_point(field_mutable:face.FaceDetectionResponse.faces)
  return _impl_.faces_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::face::Face >*
FaceDetectionResponse::mutable_faces() {
  // @@protoc_insertion_point(field_mutable_list:face.FaceDetectionResponse.faces)
  return &_impl_.faces_;
}
inline const ::face::Face& FaceDetectionResponse::_internal_faces(int index) const {
  return _impl_.faces_.Get(index);
}
inline const ::face::Face& FaceDetectionResponse::faces(int index) const {
  // @@protoc_insertion_point(field_get:face.FaceDetectionResponse.faces)
  return _internal_faces(index);
}
inline ::face::Face* FaceDetectionResponse::_internal_add_faces() {
  return _impl_.faces_.Add();
}
inline ::face::Face* FaceDetectionResponse::add_faces() {
  ::face::Face* _add = _internal_add_faces();
  // @@protoc_insertion_point(field_add:face.FaceDetectionResponse.faces)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::face::Face >&
FaceDetectionResponse::faces() const {
  // @@protoc_insertion_point(field_list:face.FaceDetectionResponse.faces)
  return _impl_.faces_;
}

// int32 error_code = 2;
inline void FaceDetectionResponse::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline int32_t FaceDetectionResponse::_internal_error_code() const {
  return _impl_.error_code_;
}
inline int32_t FaceDetectionResponse::error_code() const {
  // @@protoc_insertion_point(field_get:face.FaceDetectionResponse.error_code)
  return _internal_error_code();
}
inline void FaceDetectionResponse::_internal_set_error_code(int32_t value) {
  
  _impl_.error_code_ = value;
}
inline void FaceDetectionResponse::set_error_code(int32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:face.FaceDetectionResponse.error_code)
}

// string error_msg = 3;
inline void FaceDetectionResponse::clear_error_msg() {
  _impl_.error_msg_.ClearToEmpty();
}
inline const std::string& FaceDetectionResponse::error_msg() const {
  // @@protoc_insertion_point(field_get:face.FaceDetectionResponse.error_msg)
  return _internal_error_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FaceDetectionResponse::set_error_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:face.FaceDetectionResponse.error_msg)
}
inline std::string* FaceDetectionResponse::mutable_error_msg() {
  std::string* _s = _internal_mutable_error_msg();
  // @@protoc_insertion_point(field_mutable:face.FaceDetectionResponse.error_msg)
  return _s;
}
inline const std::string& FaceDetectionResponse::_internal_error_msg() const {
  return _impl_.error_msg_.Get();
}
inline void FaceDetectionResponse::_internal_set_error_msg(const std::string& value) {
  
  _impl_.error_msg_.Set(value, GetArenaForAllocation());
}
inline std::string* FaceDetectionResponse::_internal_mutable_error_msg() {
  
  return _impl_.error_msg_.Mutable(GetArenaForAllocation());
}
inline std::string* FaceDetectionResponse::release_error_msg() {
  // @@protoc_insertion_point(field_release:face.FaceDetectionResponse.error_msg)
  return _impl_.error_msg_.Release();
}
inline void FaceDetectionResponse::set_allocated_error_msg(std::string* error_msg) {
  if (error_msg != nullptr) {
    
  } else {
    
  }
  _impl_.error_msg_.SetAllocated(error_msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_msg_.IsDefault()) {
    _impl_.error_msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:face.FaceDetectionResponse.error_msg)
}

// -------------------------------------------------------------------

// FaceRecognitionRequest

// .face.FaceFeature feature = 1;
inline bool FaceRecognitionRequest::_internal_has_feature() const {
  return this != internal_default_instance() && _impl_.feature_ != nullptr;
}
inline bool FaceRecognitionRequest::has_feature() const {
  return _internal_has_feature();
}
inline void FaceRecognitionRequest::clear_feature() {
  if (GetArenaForAllocation() == nullptr && _impl_.feature_ != nullptr) {
    delete _impl_.feature_;
  }
  _impl_.feature_ = nullptr;
}
inline const ::face::FaceFeature& FaceRecognitionRequest::_internal_feature() const {
  const ::face::FaceFeature* p = _impl_.feature_;
  return p != nullptr ? *p : reinterpret_cast<const ::face::FaceFeature&>(
      ::face::_FaceFeature_default_instance_);
}
inline const ::face::FaceFeature& FaceRecognitionRequest::feature() const {
  // @@protoc_insertion_point(field_get:face.FaceRecognitionRequest.feature)
  return _internal_feature();
}
inline void FaceRecognitionRequest::unsafe_arena_set_allocated_feature(
    ::face::FaceFeature* feature) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.feature_);
  }
  _impl_.feature_ = feature;
  if (feature) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:face.FaceRecognitionRequest.feature)
}
inline ::face::FaceFeature* FaceRecognitionRequest::release_feature() {
  
  ::face::FaceFeature* temp = _impl_.feature_;
  _impl_.feature_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::face::FaceFeature* FaceRecognitionRequest::unsafe_arena_release_feature() {
  // @@protoc_insertion_point(field_release:face.FaceRecognitionRequest.feature)
  
  ::face::FaceFeature* temp = _impl_.feature_;
  _impl_.feature_ = nullptr;
  return temp;
}
inline ::face::FaceFeature* FaceRecognitionRequest::_internal_mutable_feature() {
  
  if (_impl_.feature_ == nullptr) {
    auto* p = CreateMaybeMessage<::face::FaceFeature>(GetArenaForAllocation());
    _impl_.feature_ = p;
  }
  return _impl_.feature_;
}
inline ::face::FaceFeature* FaceRecognitionRequest::mutable_feature() {
  ::face::FaceFeature* _msg = _internal_mutable_feature();
  // @@protoc_insertion_point(field_mutable:face.FaceRecognitionRequest.feature)
  return _msg;
}
inline void FaceRecognitionRequest::set_allocated_feature(::face::FaceFeature* feature) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.feature_;
  }
  if (feature) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(feature);
    if (message_arena != submessage_arena) {
      feature = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, feature, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.feature_ = feature;
  // @@protoc_insertion_point(field_set_allocated:face.FaceRecognitionRequest.feature)
}

// int32 top_n = 2;
inline void FaceRecognitionRequest::clear_top_n() {
  _impl_.top_n_ = 0;
}
inline int32_t FaceRecognitionRequest::_internal_top_n() const {
  return _impl_.top_n_;
}
inline int32_t FaceRecognitionRequest::top_n() const {
  // @@protoc_insertion_point(field_get:face.FaceRecognitionRequest.top_n)
  return _internal_top_n();
}
inline void FaceRecognitionRequest::_internal_set_top_n(int32_t value) {
  
  _impl_.top_n_ = value;
}
inline void FaceRecognitionRequest::set_top_n(int32_t value) {
  _internal_set_top_n(value);
  // @@protoc_insertion_point(field_set:face.FaceRecognitionRequest.top_n)
}

// float threshold = 3;
inline void FaceRecognitionRequest::clear_threshold() {
  _impl_.threshold_ = 0;
}
inline float FaceRecognitionRequest::_internal_threshold() const {
  return _impl_.threshold_;
}
inline float FaceRecognitionRequest::threshold() const {
  // @@protoc_insertion_point(field_get:face.FaceRecognitionRequest.threshold)
  return _internal_threshold();
}
inline void FaceRecognitionRequest::_internal_set_threshold(float value) {
  
  _impl_.threshold_ = value;
}
inline void FaceRecognitionRequest::set_threshold(float value) {
  _internal_set_threshold(value);
  // @@protoc_insertion_point(field_set:face.FaceRecognitionRequest.threshold)
}

// -------------------------------------------------------------------

// FaceRecognitionResponse

// repeated .face.FaceRecognitionResult results = 1;
inline int FaceRecognitionResponse::_internal_results_size() const {
  return _impl_.results_.size();
}
inline int FaceRecognitionResponse::results_size() const {
  return _internal_results_size();
}
inline void FaceRecognitionResponse::clear_results() {
  _impl_.results_.Clear();
}
inline ::face::FaceRecognitionResult* FaceRecognitionResponse::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:face.FaceRecognitionResponse.results)
  return _impl_.results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::face::FaceRecognitionResult >*
FaceRecognitionResponse::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:face.FaceRecognitionResponse.results)
  return &_impl_.results_;
}
inline const ::face::FaceRecognitionResult& FaceRecognitionResponse::_internal_results(int index) const {
  return _impl_.results_.Get(index);
}
inline const ::face::FaceRecognitionResult& FaceRecognitionResponse::results(int index) const {
  // @@protoc_insertion_point(field_get:face.FaceRecognitionResponse.results)
  return _internal_results(index);
}
inline ::face::FaceRecognitionResult* FaceRecognitionResponse::_internal_add_results() {
  return _impl_.results_.Add();
}
inline ::face::FaceRecognitionResult* FaceRecognitionResponse::add_results() {
  ::face::FaceRecognitionResult* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:face.FaceRecognitionResponse.results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::face::FaceRecognitionResult >&
FaceRecognitionResponse::results() const {
  // @@protoc_insertion_point(field_list:face.FaceRecognitionResponse.results)
  return _impl_.results_;
}

// int32 error_code = 2;
inline void FaceRecognitionResponse::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline int32_t FaceRecognitionResponse::_internal_error_code() const {
  return _impl_.error_code_;
}
inline int32_t FaceRecognitionResponse::error_code() const {
  // @@protoc_insertion_point(field_get:face.FaceRecognitionResponse.error_code)
  return _internal_error_code();
}
inline void FaceRecognitionResponse::_internal_set_error_code(int32_t value) {
  
  _impl_.error_code_ = value;
}
inline void FaceRecognitionResponse::set_error_code(int32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:face.FaceRecognitionResponse.error_code)
}

// string error_msg = 3;
inline void FaceRecognitionResponse::clear_error_msg() {
  _impl_.error_msg_.ClearToEmpty();
}
inline const std::string& FaceRecognitionResponse::error_msg() const {
  // @@protoc_insertion_point(field_get:face.FaceRecognitionResponse.error_msg)
  return _internal_error_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FaceRecognitionResponse::set_error_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:face.FaceRecognitionResponse.error_msg)
}
inline std::string* FaceRecognitionResponse::mutable_error_msg() {
  std::string* _s = _internal_mutable_error_msg();
  // @@protoc_insertion_point(field_mutable:face.FaceRecognitionResponse.error_msg)
  return _s;
}
inline const std::string& FaceRecognitionResponse::_internal_error_msg() const {
  return _impl_.error_msg_.Get();
}
inline void FaceRecognitionResponse::_internal_set_error_msg(const std::string& value) {
  
  _impl_.error_msg_.Set(value, GetArenaForAllocation());
}
inline std::string* FaceRecognitionResponse::_internal_mutable_error_msg() {
  
  return _impl_.error_msg_.Mutable(GetArenaForAllocation());
}
inline std::string* FaceRecognitionResponse::release_error_msg() {
  // @@protoc_insertion_point(field_release:face.FaceRecognitionResponse.error_msg)
  return _impl_.error_msg_.Release();
}
inline void FaceRecognitionResponse::set_allocated_error_msg(std::string* error_msg) {
  if (error_msg != nullptr) {
    
  } else {
    
  }
  _impl_.error_msg_.SetAllocated(error_msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_msg_.IsDefault()) {
    _impl_.error_msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:face.FaceRecognitionResponse.error_msg)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace face

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::face::FaceAttributes_Gender> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::face::FaceAttributes_Gender>() {
  return ::face::FaceAttributes_Gender_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_face_2eproto
